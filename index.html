<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BareBlocks - Metadata Inspector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            background: #0d1117;
            color: #c9d1d9;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .terminal-container {
            width: 100%;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background: #0d1117;
        }
        
        .terminal-header {
            background: #161b22;
            padding: 10px 20px;
            border-bottom: 1px solid #30363d;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .terminal-title-area {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .terminal-title {
            color: #6FC3DF;
            font-weight: bold;
            font-size: 14px;
        }
        
        .thumbnail-container {
            display: none;
            align-items: center;
            max-height: 60px;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #30363d;
        }
        
        .thumbnail-container.visible {
            display: flex;
        }
        
        .thumbnail-container img {
            max-height: 60px;
            max-width: 80px;
            object-fit: contain;
        }
        
        .terminal-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tab-button {
            background: transparent;
            border: 1px solid #30363d;
            color: #8b949e;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            transition: all 0.2s;
            touch-action: manipulation;
        }
        
        .tab-button:hover {
            background: #21262d;
            color: #c9d1d9;
            border-color: #6FC3DF;
        }
        
        .tab-button.active {
            background: #0d1117;
            color: #6FC3DF;
            border-color: #6FC3DF;
        }
        
        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .upload-zone {
            border: 2px dashed #30363d;
            border-radius: 8px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #161b22;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .upload-zone:hover,
        .upload-zone.drag-over {
            border-color: #6FC3DF;
            background: #1c2128;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        #fileInput {
            display: none;
        }
        
        .output-line {
            margin: 5px 0;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .prompt {
            color: #6FC3DF;
        }
        
        .success {
            color: #3fb950;
        }
        
        .error {
            color: #f85149;
        }
        
        .info {
            color: #8b949e;
        }
        
        /* Category colors */
        .category-structure { color: #FF6AC1; }
        .category-metadata { color: #FFA657; }
        .category-payloads { color: #6FC3DF; }
        .category-ai { color: #7EE787; }
        
        /* Copy button */
        .copy-icon, .copy-text-btn {
            cursor: pointer;
            margin-left: 8px;
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            background: #21262d;
            border: 1px solid #30363d;
            font-size: 11px;
            transition: all 0.2s;
            min-width: 32px;
            min-height: 32px;
            text-align: center;
            line-height: 28px;
        }
        
        .copy-icon:hover, .copy-text-btn:hover {
            background: #30363d;
            border-color: #6FC3DF;
        }
        
        .copy-icon.copied {
            background: #3fb950;
            border-color: #3fb950;
        }
        
        /* Metadata tables */
        .metadata-section {
            margin: 20px 0;
            background: #161b22;
            border-radius: 6px;
            padding: 15px;
            border: 1px solid #30363d;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #30363d;
        }
        
        .metadata-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            overflow-x: auto;
            display: block;
        }
        
        .metadata-table tbody {
            display: table;
            width: 100%;
        }
        
        .metadata-table tr {
            border-bottom: 1px solid #21262d;
        }
        
        .metadata-table td {
            padding: 8px;
            vertical-align: top;
        }
        
        .metadata-table td:first-child {
            color: #8b949e;
            width: 35%;
            font-weight: 500;
        }
        
        .metadata-table td:last-child {
            color: #c9d1d9;
            word-break: break-word;
        }
        
        .provenance-summary {
            background: #1c2128;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 13px;
        }
        
        .found {
            color: #3fb950;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .not-found {
            color: #f85149;
        }
        
        .section-highlight {
            animation: highlight-pulse 2s ease-in-out;
        }
        
        @keyframes highlight-pulse {
            0%, 100% { background: #161b22; }
            50% { background: #1c2128; border-color: #6FC3DF; }
        }
        
        /* Chunks visualization */
        .chunks-container {
            margin: 20px 0;
        }
        
        .heatmap-container {
            background: #161b22;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #30363d;
        }
        
        .heatmap {
            width: 100%;
            height: 40px;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .heatmap-segment {
            height: 100%;
            cursor: pointer;
            transition: opacity 0.2s;
            position: relative;
            min-height: 30px;
        }
        
        .heatmap-segment:hover {
            opacity: 0.8;
        }
        
        .chunk-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
            font-size: 11px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
        
        .chunk-list {
            margin-top: 20px;
        }
        
        .chunk-item {
            background: #1c2128;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 10px;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .chunk-type-label {
            color: #6FC3DF;
            cursor: help;
            text-decoration: underline dotted;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .terminal-container {
                min-height: 100vh;
            }
            
            .terminal-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .terminal-tabs {
                width: 100%;
                flex-direction: column;
            }
            
            .tab-button {
                padding: 12px 20px;
                font-size: 14px;
                min-height: 44px;
                width: 100%;
            }
            
            .upload-zone {
                padding: 40px 20px;
                min-height: 200px;
            }
            
            .metadata-table td:first-child {
                width: 40%;
            }
            
            .copy-icon, .copy-text-btn {
                min-width: 44px;
                min-height: 44px;
                padding: 8px;
            }
            
            .thumbnail-container img {
                max-width: 60px;
                max-height: 50px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                font-size: 12px;
            }
            
            .metadata-table {
                font-size: 11px;
            }
            
            .metadata-table td {
                padding: 6px;
            }
            
            .section-title {
                font-size: 14px;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .tab-button:hover {
                background: transparent;
            }
            
            .tab-button:active {
                background: #21262d;
                transform: scale(0.98);
            }
            
            button, .copy-icon, .copy-text-btn, .chunk-type-label {
                touch-action: manipulation;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="terminal-header">
            <div class="terminal-title-area">
                <div class="terminal-title">üóÄ BareBlocks - Metadata Inspector</div>
                <div class="thumbnail-container" id="thumbnailContainer">
                    <img id="thumbnailImage" alt="Thumbnail">
                </div>
            </div>
            <div class="terminal-tabs">
                <button class="tab-button active" onclick="switchTab('terminal')">üìü Terminal</button>
                <button class="tab-button" onclick="switchTab('chunks')">üß© Chunks</button>
                <button class="tab-button" onclick="exportJSON()">üíæ Export JSON</button>
            </div>
        </div>
        
        <div class="terminal-content">
            <!-- Terminal Tab -->
            <div id="terminal-tab" class="tab-content active">
                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon">üóÄ</div>
                    <div>Click or drag file here to analyze</div>
                    <div class="info" style="margin-top: 10px; font-size: 11px;">
                        Supports: JPEG, PNG, TIFF, HEIC<br>
                        All processing happens in your browser - files never uploaded
                    </div>
                </div>
                <input type="file" id="fileInput" accept="image/*">
                <div id="output"></div>
            </div>
            
            <!-- Chunks Tab -->
            <div id="chunks-tab" class="tab-content">
                <div class="chunks-container">
                    <h2 class="section-title category-structure">File Structure Visualization</h2>
                    <div id="chunksVisualization">
                        <p class="info">Upload a file to see its structure</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Load exifr library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/exifr@latest/dist/full.umd.js"></script>
    
    <script>
        // Global state
        let currentFile = null;
        let currentMetadata = null;
        
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }
        
        // File upload handling
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const output = document.getElementById('output');
        
        uploadZone.addEventListener('click', () => fileInput.click());
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('drag-over');
        });
        
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('drag-over');
        });
        
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                processFile(e.dataTransfer.files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        });
        
        // Main file processing function
        async function processFile(file) {
            currentFile = file;
            output.innerHTML = '<div class="output-line"><span class="prompt">$</span> Analyzing file...</div>';
            
            try {
                // Show thumbnail
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        document.getElementById('thumbnailImage').src = e.target.result;
                        document.getElementById('thumbnailContainer').classList.add('visible');
                    };
                    reader.readAsDataURL(file);
                } else {
                    document.getElementById('thumbnailContainer').classList.remove('visible');
                }
                
                // Extract metadata
                const metadata = await extractMetadata(file);
                currentMetadata = metadata;
                
                // Display results
                displayMetadata(metadata);
                
                // Update chunks visualization
                if (metadata.chunks) {
                    updateChunksVisualization(metadata.chunks, file);
                }
                
            } catch (error) {
                output.innerHTML += `<div class="output-line error">Error: ${error.message}</div>`;
                console.error('Processing error:', error);
            }
        }
        
        // Metadata extraction (pure JavaScript)
        async function extractMetadata(file) {
            const result = {
                fileName: file.name,
                fileSize: file.size,
                mimeType: file.type,
                containerType: getContainerType(file),
            };
            
            // Extract EXIF/IPTC/XMP using exifr
            try {
                const exifData = await exifr.parse(file, {
                    tiff: true,
                    exif: true,
                    gps: true,
                    iptc: true,
                    icc: true,
                    jfif: true,
                    ihdr: true,
                    translateKeys: false,
                    translateValues: false,
                    reviveValues: true,
                    sanitize: false,
                    mergeOutput: false,
                });
                
                if (exifData) {
                    result.exif = exifData;
                }
                
                // GPS coordinates
                const gps = await exifr.gps(file);
                if (gps) {
                    result.gps = {
                        latitude: gps.latitude,
                        longitude: gps.longitude,
                        formatted: `${gps.latitude}, ${gps.longitude}`
                    };
                }
                
            } catch (error) {
                console.warn('EXIF extraction error:', error);
            }
            
            // Parse file structure (PNG chunks, JPEG segments, etc.)
            const arrayBuffer = await file.arrayBuffer();
            
            if (file.name.toLowerCase().endsWith('.png')) {
                result.chunks = await parsePngChunks(arrayBuffer);
                result.pngTextChunks = extractPngTextChunks(result.chunks);
            } else if (file.type === 'image/jpeg' || file.name.toLowerCase().endsWith('.jpg')) {
                result.chunks = await parseJpegSegments(arrayBuffer);
            }
            
            // Detect AI metadata
            result.aiMetadata = detectAIMetadata(result);
            
            // Determine provenance
            result.provenance = determineProvenance(result);
            
            return result;
        }
        
        // PNG chunk parser
        async function parsePngChunks(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const chunks = [];
            
            // Check PNG signature
            if (view.getUint32(0) !== 0x89504E47 || view.getUint32(4) !== 0x0D0A1A0A) {
                throw new Error('Not a valid PNG file');
            }
            
            let offset = 8; // Skip PNG signature
            
            while (offset < arrayBuffer.byteLength - 12) {
                const length = view.getUint32(offset);
                offset += 4;
                
                const typeBytes = new Uint8Array(arrayBuffer, offset, 4);
                const chunkType = String.fromCharCode(...typeBytes);
                offset += 4;
                
                const data = new Uint8Array(arrayBuffer, offset, length);
                offset += length;
                
                const crc = view.getUint32(offset);
                offset += 4;
                
                chunks.push({
                    type: chunkType,
                    length: length,
                    data: data,
                    offset: offset - length - 12,
                    crc: crc
                });
                
                if (chunkType === 'IEND') break;
            }
            
            return chunks;
        }
        
        // JPEG segment parser (simplified)
        async function parseJpegSegments(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const segments = [];
            
            let offset = 0;
            
            // Check JPEG signature
            if (view.getUint16(0) !== 0xFFD8) {
                throw new Error('Not a valid JPEG file');
            }
            
            offset = 2;
            
            while (offset < arrayBuffer.byteLength - 4) {
                const marker = view.getUint16(offset);
                
                if ((marker & 0xFF00) !== 0xFF00) break;
                
                offset += 2;
                
                // Markers without length
                if (marker === 0xFFD8 || marker === 0xFFD9 || (marker >= 0xFFD0 && marker <= 0xFFD7)) {
                    segments.push({
                        type: `0x${marker.toString(16).toUpperCase()}`,
                        length: 0,
                        offset: offset - 2
                    });
                    continue;
                }
                
                const length = view.getUint16(offset);
                
                segments.push({
                    type: `0x${marker.toString(16).toUpperCase()}`,
                    typeName: getJpegMarkerName(marker),
                    length: length,
                    offset: offset - 2
                });
                
                offset += length;
            }
            
            return segments;
        }
        
        function getJpegMarkerName(marker) {
            const names = {
                0xFFC0: 'SOF0 (Baseline DCT)',
                0xFFC4: 'DHT (Huffman Table)',
                0xFFD8: 'SOI (Start of Image)',
                0xFFD9: 'EOI (End of Image)',
                0xFFDA: 'SOS (Start of Scan)',
                0xFFDB: 'DQT (Quantization Table)',
                0xFFE0: 'APP0 (JFIF)',
                0xFFE1: 'APP1 (EXIF/XMP)',
                0xFFE2: 'APP2 (ICC Profile)',
                0xFFFE: 'COM (Comment)',
            };
            return names[marker] || 'Unknown';
        }
        
        // Extract text from PNG text chunks
        function extractPngTextChunks(chunks) {
            if (!chunks) return null;
            
            const textChunks = [];
            const decoder = new TextDecoder('utf-8');
            
            for (const chunk of chunks) {
                if (chunk.type === 'tEXt' || chunk.type === 'iTXt' || chunk.type === 'zTXt') {
                    try {
                        // Find null terminator (keyword/text separator)
                        let nullIndex = 0;
                        while (nullIndex < chunk.data.length && chunk.data[nullIndex] !== 0) {
                            nullIndex++;
                        }
                        
                        const keyword = decoder.decode(chunk.data.slice(0, nullIndex));
                        let text = '';
                        
                        if (chunk.type === 'tEXt') {
                            text = decoder.decode(chunk.data.slice(nullIndex + 1));
                        } else if (chunk.type === 'iTXt') {
                            // iTXt has: keyword, null, compression flag, compression method, null, language tag, null, translated keyword, null, text
                            try {
                                text = decoder.decode(chunk.data.slice(nullIndex + 1));
                            } catch (e) {
                                text = '(binary data)';
                            }
                        }
                        
                        textChunks.push({ keyword, text, type: chunk.type });
                    } catch (e) {
                        console.warn('Error parsing text chunk:', e);
                    }
                }
            }
            
            return textChunks.length > 0 ? textChunks : null;
        }
        
        // AI metadata detection
        function detectAIMetadata(metadata) {
            const ai = {
                hasComfyUI: false,
                hasStableDiffusion: false,
                model: null,
                prompt: null,
                workflow: null,
                wildcards: [],
            };
            
            // Check EXIF software tag
            if (metadata.exif) {
                const software = metadata.exif.Software || metadata.exif.software;
                if (software) {
                    if (typeof software === 'string' && software.toLowerCase().includes('comfy')) {
                        ai.hasComfyUI = true;
                    }
                    if (typeof software === 'string' && software.toLowerCase().includes('stable')) {
                        ai.hasStableDiffusion = true;
                    }
                }
                
                // Check for model in parameters
                const params = metadata.exif.Parameters || metadata.exif.parameters;
                if (params && typeof params === 'string') {
                    const modelMatch = params.match(/Model:\s*([^\n,]+)/i);
                    if (modelMatch) {
                        ai.model = modelMatch[1].trim();
                    }
                }
            }
            
            // Check PNG text chunks for workflow
            if (metadata.pngTextChunks) {
                for (const chunk of metadata.pngTextChunks) {
                    const keyLower = chunk.keyword.toLowerCase();
                    const textLower = chunk.text.toLowerCase();
                    
                    if (keyLower.includes('workflow') || keyLower.includes('comfy')) {
                        ai.hasComfyUI = true;
                        try {
                            ai.workflow = JSON.parse(chunk.text);
                        } catch (e) {
                            // Not JSON
                        }
                    }
                    
                    if (keyLower.includes('prompt')) {
                        ai.prompt = chunk.text;
                        
                        // Detect wildcards
                        const wildcardMatches = chunk.text.match(/__[^_]+__/g);
                        if (wildcardMatches) {
                            ai.wildcards = wildcardMatches;
                        }
                    }
                    
                    if (!ai.model && (keyLower.includes('model') || keyLower.includes('checkpoint'))) {
                        ai.model = chunk.text;
                    }
                }
            }
            
            return ai;
        }
        
        // Determine image provenance
        function determineProvenance(metadata) {
            const hasCamera = metadata.exif && (
                metadata.exif.Make || metadata.exif.Model || 
                metadata.exif.LensModel || metadata.exif.LensMake
            );
            
            const hasAI = metadata.aiMetadata && (
                metadata.aiMetadata.hasComfyUI || 
                metadata.aiMetadata.hasStableDiffusion ||
                metadata.aiMetadata.model
            );
            
            if (hasCamera && !hasAI) return 'camera';
            if (hasAI && !hasCamera) return 'ai';
            if (hasCamera && hasAI) return 'mixed';
            return 'unclear';
        }
        
        function getContainerType(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            const types = {
                'jpg': 'JPEG', 'jpeg': 'JPEG', 'png': 'PNG',
                'gif': 'GIF', 'tiff': 'TIFF', 'tif': 'TIFF',
                'heic': 'HEIC', 'webp': 'WebP'
            };
            return types[ext] || 'Unknown';
        }
        
        // Display metadata in terminal
        function displayMetadata(metadata) {
            let html = '<div class="output-line success">‚úì Metadata extracted successfully</div>';
            
            // Provenance summary
            html += '<div class="provenance-summary">';
            if (metadata.provenance === 'camera') {
                const camera = metadata.exif?.Make || 'Unknown';
                const model = metadata.exif?.Model || '';
                html += `üì∑ This image was taken by a camera: <strong>${camera} ${model}</strong><br>`;
            } else if (metadata.provenance === 'ai') {
                const model = metadata.aiMetadata?.model || 'Unknown AI model';
                html += `ü§ñ This image has AI metadata: <strong>${model}</strong><br>`;
            } else {
                html += `‚ùì Not enough metadata to indicate provenance.<br>`;
            }
            
            if (metadata.gps) {
                html += `üìç GPS: <span class="copy-icon" onclick="copyToClipboard('${metadata.gps.formatted}', this)">üìã</span> ${metadata.gps.formatted}<br>`;
            }
            
            html += `</div>`;
            
            // Summary section
            html += '<div class="metadata-section"><div class="section-title category-structure">üìä Summary</div>';
            html += '<table class="metadata-table"><tbody>';
            html += `<tr><td>Container Type</td><td class="category-structure">${metadata.containerType}</td></tr>`;
            html += `<tr><td>File Size (MB)</td><td class="category-structure">${(metadata.fileSize / 1024 / 1024).toFixed(2)}</td></tr>`;
            html += `<tr><td>File Name</td><td>${metadata.fileName}</td></tr>`;
            html += `<tr><td>MIME Type</td><td>${metadata.mimeType}</td></tr>`;
            html += '</tbody></table></div>';
            
            // EXIF section
            if (metadata.exif) {
                html += '<div class="metadata-section" id="section-exif"><div class="section-title category-metadata">üì∑ Declared Metadata (EXIF)</div>';
                html += '<table class="metadata-table"><tbody>';
                
                for (const [key, value] of Object.entries(metadata.exif)) {
                    if (value !== null && value !== undefined) {
                        const displayKey = key.replace(/^(EXIF|GPS|Image|Interoperability)\s+/i, '');
                        const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
                        html += `<tr><td>${displayKey}</td><td>${escapeHtml(displayValue)}</td></tr>`;
                    }
                }
                
                html += '</tbody></table></div>';
            }
            
            // AI Metadata section
            if (metadata.aiMetadata && (metadata.aiMetadata.hasComfyUI || metadata.aiMetadata.model || metadata.aiMetadata.prompt)) {
                html += '<div class="metadata-section" id="section-ai"><div class="section-title category-ai">ü§ñ Encryption and AI</div>';
                html += '<table class="metadata-table"><tbody>';
                
                if (metadata.aiMetadata.model) {
                    html += `<tr><td>Model</td><td>${escapeHtml(metadata.aiMetadata.model)}</td></tr>`;
                }
                
                if (metadata.aiMetadata.prompt) {
                    html += `<tr><td>Prompt</td><td>${escapeHtml(metadata.aiMetadata.prompt)} <span class="copy-text-btn" data-text="${escapeHtml(metadata.aiMetadata.prompt)}">üìã</span></td></tr>`;
                }
                
                if (metadata.aiMetadata.wildcards && metadata.aiMetadata.wildcards.length > 0) {
                    html += `<tr><td>Wildcards Used</td><td>${metadata.aiMetadata.wildcards.length}</td></tr>`;
                }
                
                html += '</tbody></table></div>';
            }
            
            output.innerHTML = html;
        }
        
        // Chunks visualization
        function updateChunksVisualization(chunks, file) {
            if (!chunks || chunks.length === 0) return;
            
            const container = document.getElementById('chunksVisualization');
            let html = '';
            
            // Heatmap
            html += '<div class="heatmap-container">';
            html += '<h3>File Structure Heatmap</h3>';
            html += '<div class="heatmap">';
            
            const colors = {
                'IHDR': '#FF6AC1', 'IDAT': '#6FC3DF', 'IEND': '#3fb950',
                'tEXt': '#7EE787', 'iTXt': '#7EE787', 'zTXt': '#7EE787',
                'gAMA': '#FFA657', 'cHRM': '#FFA657', 'sRGB': '#FFA657',
                'iCCP': '#F778BA', 'pHYs': '#8b949e',
            };
            
            for (const chunk of chunks) {
                const color = colors[chunk.type] || '#30363d';
                const percent = (chunk.length / file.size * 100).toFixed(2);
                html += `<div class="heatmap-segment" style="width: ${percent}%; background: ${color};" title="${chunk.type}: ${chunk.length} bytes"></div>`;
            }
            
            html += '</div>';
            
            // Legend
            html += '<div class="chunk-legend">';
            const usedTypes = [...new Set(chunks.map(c => c.type))];
            for (const type of usedTypes) {
                const color = colors[type] || '#30363d';
                html += `<div class="legend-item"><div class="legend-color" style="background: ${color};"></div>${type}</div>`;
            }
            html += '</div></div>';
            
            // Chunk list
            html += '<div class="chunk-list"><h3>Chunk Details</h3>';
            chunks.forEach((chunk, i) => {
                html += `<div class="chunk-item">`;
                html += `<strong>${i + 1}.</strong> `;
                html += `Type: <span class="chunk-type-label">${chunk.type}</span> | `;
                html += `Length: ${chunk.length.toLocaleString()} bytes | `;
                html += `Offset: 0x${chunk.offset.toString(16).toUpperCase()}`;
                html += `</div>`;
            });
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        // Export JSON
        function exportJSON() {
            if (!currentMetadata) {
                alert('No metadata to export. Please analyze a file first.');
                return;
            }
            
            const fileName = currentFile.name.replace(/\.[^/.]+$/, "");
            const containerType = currentMetadata.containerType.toLowerCase();
            const exportName = `${fileName}_${containerType}_metadata.json`;
            
            const blob = new Blob([JSON.stringify(currentMetadata, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = exportName;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Copy to clipboard
        function copyToClipboard(text, element) {
            navigator.clipboard.writeText(text).then(() => {
                element.classList.add('copied');
                setTimeout(() => element.classList.remove('copied'), 2000);
            });
        }
        
        // Copy button event delegation
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('copy-text-btn')) {
                const text = e.target.getAttribute('data-text');
                copyToClipboard(text, e.target);
            }
        });
        
        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        console.log('üóÄ BareBlocks - Client-side metadata inspector ready');
        console.log('‚úÖ All processing happens in your browser');
        console.log('üîí Files never leave your device');
    </script>
</body>
</html>
