<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BareBlocks - Metadata Inspector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            background: #0d1117;
            color: #c9d1d9;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .terminal-container {
            width: 100%;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background: #0d1117;
        }
        
        .terminal-header {
            background: #161b22;
            padding: 10px 20px;
            border-bottom: 1px solid #30363d;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .terminal-title-area {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .terminal-title {
            color: #6FC3DF;
            font-weight: bold;
            font-size: 14px;
        }
        
        .thumbnail-container {
            display: none;
            align-items: center;
            max-height: 60px;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #30363d;
        }
        
        .thumbnail-container.visible {
            display: flex;
        }
        
        .thumbnail-container img {
            max-height: 60px;
            max-width: 80px;
            object-fit: contain;
        }
        
        .terminal-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tab-button {
            background: transparent;
            border: 1px solid #30363d;
            color: #8b949e;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            transition: all 0.2s;
            touch-action: manipulation;
        }
        
        .tab-button:hover {
            background: #21262d;
            color: #c9d1d9;
            border-color: #6FC3DF;
        }
        
        .tab-button.active {
            background: #0d1117;
            color: #6FC3DF;
            border-color: #6FC3DF;
        }
        
        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .upload-zone {
            border: 2px dashed #30363d;
            border-radius: 8px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #161b22;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .upload-zone:hover,
        .upload-zone.drag-over {
            border-color: #6FC3DF;
            background: #1c2128;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        #fileInput {
            display: none;
        }
        
        .output-line {
            margin: 5px 0;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .prompt {
            color: #6FC3DF;
        }
        
        .success {
            color: #3fb950;
        }
        
        .error {
            color: #f85149;
        }
        
        .info {
            color: #8b949e;
        }
        
        /* Category colors */
        .category-structure { color: #FF6AC1; }
        .category-metadata { color: #FFA657; }
        .category-payloads { color: #6FC3DF; }
        .category-ai { color: #7EE787; }
        
        /* Copy button */
        .copy-icon, .copy-text-btn {
            cursor: pointer;
            margin-left: 8px;
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            background: #21262d;
            border: 1px solid #30363d;
            font-size: 11px;
            transition: all 0.2s;
            min-width: 32px;
            min-height: 32px;
            text-align: center;
            line-height: 28px;
        }
        
        .copy-icon:hover, .copy-text-btn:hover {
            background: #30363d;
            border-color: #6FC3DF;
        }
        
        .copy-icon.copied {
            background: #3fb950;
            border-color: #3fb950;
        }
        
        /* Metadata tables */
        .metadata-section {
            margin: 10px 0;
            background: #161b22;
            border-radius: 4px;
            padding: 10px;
            border: 1px solid #30363d;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #30363d;
        }
        
        .metadata-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            overflow-x: auto;
            display: block;
        }
        
        .metadata-table tbody {
            display: table;
            width: 100%;
        }
        
        .metadata-table tr {
            border-bottom: 1px solid #21262d;
        }
        
        .metadata-table td {
            padding: 4px 8px;
            vertical-align: top;
        }
        
        .metadata-table td:first-child {
            color: #8b949e;
            width: 35%;
            font-weight: 500;
        }
        
        .metadata-table td:last-child {
            color: #c9d1d9;
            word-break: break-word;
        }
        
        /* Expandable rows */
        .expandable {
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .expandable:hover {
            background: #1c2128;
        }
        
        .toggle {
            display: inline-block;
            color: #6FC3DF;
            font-weight: bold;
            margin-left: 8px;
            user-select: none;
            min-width: 15px;
            text-align: center;
        }
        
        .nested {
            background: #0d1117;
        }
        
        .provenance-summary {
            background: #1c2128;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 10px;
            font-size: 12px;
        }
        
        .found {
            color: #3fb950;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .not-found {
            color: #f85149;
        }
        
        .section-highlight {
            animation: highlight-pulse 2s ease-in-out;
            border: 2px solid #6FC3DF !important;
        }
        
        @keyframes highlight-pulse {
            0%, 100% { 
                background: #161b22; 
                border-color: #6FC3DF;
            }
            50% { 
                background: #1c2128; 
                border-color: #3fb950;
            }
        }
        
        /* Data recap styles */
        .data-recap {
            margin: 6px 0;
            font-size: 11px;
            line-height: 1.5;
        }
        
        .recap-item {
            display: inline-block;
            margin-right: 12px;
            margin-bottom: 3px;
        }
        
        /* Category colors for table headers */
        .category-anomaly {
            color: #f85149;
        }
        
        /* Chunks visualization */
        .chunks-container {
            margin: 20px 0;
        }
        
        .heatmap-container {
            background: #161b22;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #30363d;
        }
        
        .heatmap {
            width: 100%;
            height: 40px;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .heatmap-segment {
            height: 100%;
            cursor: pointer;
            transition: opacity 0.2s;
            position: relative;
            min-height: 30px;
        }
        
        .heatmap-segment:hover {
            opacity: 0.8;
        }
        
        .chunk-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
            font-size: 11px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
        
        .chunk-list {
            margin-top: 20px;
        }
        
        .chunk-item {
            background: #1c2128;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 10px;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .chunk-type-label {
            color: #6FC3DF;
            cursor: help;
            text-decoration: underline dotted;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .terminal-container {
                min-height: 100vh;
            }
            
            .terminal-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .terminal-tabs {
                width: 100%;
                flex-direction: column;
            }
            
            .tab-button {
                padding: 12px 20px;
                font-size: 14px;
                min-height: 44px;
                width: 100%;
            }
            
            .upload-zone {
                padding: 40px 20px;
                min-height: 200px;
            }
            
            .metadata-table td:first-child {
                width: 40%;
            }
            
            .copy-icon, .copy-text-btn {
                min-width: 44px;
                min-height: 44px;
                padding: 8px;
            }
            
            .thumbnail-container img {
                max-width: 60px;
                max-height: 50px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                font-size: 12px;
            }
            
            .metadata-table {
                font-size: 11px;
            }
            
            .metadata-table td {
                padding: 6px;
            }
            
            .section-title {
                font-size: 14px;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .tab-button:hover {
                background: transparent;
            }
            
            .tab-button:active {
                background: #21262d;
                transform: scale(0.98);
            }
            
            button, .copy-icon, .copy-text-btn, .chunk-type-label {
                touch-action: manipulation;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="terminal-header">
            <div class="terminal-title-area">
                <div class="terminal-title">$ BareBlocks - Metadata Inspector</div>
                <div class="thumbnail-container" id="thumbnailContainer">
                    <img id="thumbnailImage" alt="Thumbnail">
                </div>
            </div>
            <div class="terminal-tabs">
                <button class="tab-button active" onclick="switchTab('terminal')">Terminal</button>
                <button class="tab-button" onclick="switchTab('chunks')">Chunks</button>
                <button class="tab-button" onclick="exportJSON()">Export JSON</button>
            </div>
        </div>
        
        <div class="terminal-content">
            <!-- Terminal Tab -->
            <div id="terminal-tab" class="tab-content active">
                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon">[   ]</div>
                    <div>Click or drag file here to analyze</div>
                    <div class="info" style="margin-top: 10px; font-size: 11px;">
                        Supports: JPEG, PNG, TIFF, HEIC<br>
                        All processing happens in your browser - files never uploaded
                    </div>
                </div>
                <input type="file" id="fileInput" accept="image/*">
                <div id="output"></div>
            </div>
            
            <!-- Chunks Tab -->
            <div id="chunks-tab" class="tab-content">
                <div class="chunks-container">
                    <h2 class="section-title category-structure">File Structure Visualization</h2>
                    <div id="chunksVisualization">
                        <p class="info">Upload a file to see its structure</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Load exifr library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/exifr@latest/dist/full.umd.js"></script>
    
    <!-- Load pako for zlib decompression -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    
    <script>
        // Global state
        let currentFile = null;
        let currentMetadata = null;
        
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }
        
        // File upload handling
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const output = document.getElementById('output');
        
        uploadZone.addEventListener('click', () => fileInput.click());
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('drag-over');
        });
        
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('drag-over');
        });
        
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                processFile(e.dataTransfer.files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        });
        
        // Main file processing function
        async function processFile(file) {
            currentFile = file;
            output.innerHTML = '<div class="output-line"><span class="prompt">$</span> Analyzing file...</div>';
            
            try {
                // Show thumbnail
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        document.getElementById('thumbnailImage').src = e.target.result;
                        document.getElementById('thumbnailContainer').classList.add('visible');
                    };
                    reader.readAsDataURL(file);
                } else {
                    document.getElementById('thumbnailContainer').classList.remove('visible');
                }
                
                // Extract metadata
                const metadata = await extractMetadata(file);
                currentMetadata = metadata;
                
                // Display results
                displayMetadata(metadata);
                
                // Update chunks visualization
                if (metadata.chunks) {
                    updateChunksVisualization(metadata.chunks, file);
                }
                
            } catch (error) {
                output.innerHTML += `<div class="output-line error">Error: ${error.message}</div>`;
                console.error('Processing error:', error);
            }
        }
        
        // Calculate PNG structure data
        function calculatePngStructure(chunks, totalSize) {
            if (!chunks || chunks.length === 0) return null;
            
            let pixelDataBytes = 0;
            let nonPixelBytes = 8; // PNG signature
            
            // Calculate bytes for each chunk type
            for (const chunk of chunks) {
                const chunkTotalSize = chunk.length + 12; // length (4) + type (4) + data + crc (4)
                
                if (chunk.type === 'IDAT') {
                    pixelDataBytes += chunkTotalSize;
                } else {
                    nonPixelBytes += chunkTotalSize;
                }
            }
            
            return {
                format: 'PNG',
                totalChunks: chunks.length,
                pixelDataBytes: pixelDataBytes,
                nonPixelBytes: nonPixelBytes,
                nonPixelRatio: (nonPixelBytes / totalSize).toFixed(4),
                chunks: chunks.map(c => ({
                    type: c.type,
                    offset: c.offset,
                    size: c.length,
                    hasData: c.length > 0
                }))
            };
        }
        
        // Calculate JPEG structure data
        function calculateJpegStructure(segments, totalSize) {
            if (!segments || segments.length === 0) return null;
            
            let pixelDataBytes = 0;
            let nonPixelBytes = 0;
            
            for (const segment of segments) {
                if (segment.type === '0xFFDA') { // SOS (Start of Scan) - contains pixel data
                    pixelDataBytes += segment.length || 0;
                } else {
                    nonPixelBytes += (segment.length || 0) + 2; // marker (2 bytes)
                }
            }
            
            return {
                format: 'JPEG',
                totalSegments: segments.length,
                pixelDataBytes: pixelDataBytes,
                nonPixelBytes: nonPixelBytes,
                nonPixelRatio: (nonPixelBytes / totalSize).toFixed(4),
                segments: segments.map(s => ({
                    type: s.type,
                    typeName: s.typeName,
                    offset: s.offset,
                    size: s.length,
                    hasData: (s.length || 0) > 0
                }))
            };
        }
        
        // Calculate anomalies
        function calculateAnomalies(metadata) {
            const anomalies = {
                fileSize: metadata.fileSize,
                pixelDataBytes: metadata.structure?.pixelDataBytes || 0,
                nonPixelBytes: metadata.structure?.nonPixelBytes || 0,
                nonPixelRatio: metadata.structure?.nonPixelRatio || 0,
                flags: []
            };
            
            // Check for custom chunks (PNG)
            if (metadata.chunks) {
                const standardPngChunks = ['IHDR', 'PLTE', 'IDAT', 'IEND', 'tRNS', 'gAMA', 'cHRM', 'sRGB', 'iCCP', 'tEXt', 'zTXt', 'iTXt', 'bKGD', 'pHYs', 'sBIT', 'sPLT', 'hIST', 'tIME'];
                const customChunks = metadata.chunks.filter(c => !standardPngChunks.includes(c.type));
                if (customChunks.length > 0) {
                    anomalies.flags.push('custom_chunks_present');
                }
            }
            
            // Check for high metadata ratio
            if (parseFloat(anomalies.nonPixelRatio) > 0.2) {
                anomalies.flags.push('high_metadata_ratio');
            }
            
            // Check for AI metadata
            if (metadata.aiMetadata?.hasComfyUI || metadata.aiMetadata?.hasStableDiffusion) {
                anomalies.flags.push('ai_metadata_present');
            }
            
            return anomalies;
        }
        
        // Metadata extraction (pure JavaScript)
        async function extractMetadata(file) {
            const result = {
                fileName: file.name,
                fileSize: file.size,
                mimeType: file.type,
                containerType: getContainerType(file),
            };
            
            // Extract EXIF/IPTC/XMP using exifr
            try {
                const exifData = await exifr.parse(file, {
                    tiff: true,
                    exif: true,
                    gps: true,
                    iptc: true,
                    icc: true,
                    jfif: true,
                    ihdr: true,
                    translateKeys: false,
                    translateValues: false,
                    reviveValues: true,
                    sanitize: false,
                    mergeOutput: false,
                });
                
                if (exifData) {
                    result.exif = exifData;
                }
                
                // GPS coordinates
                const gps = await exifr.gps(file);
                if (gps) {
                    result.gps = {
                        latitude: gps.latitude,
                        longitude: gps.longitude,
                        formatted: `${gps.latitude}, ${gps.longitude}`
                    };
                }
                
            } catch (error) {
                console.warn('EXIF extraction error:', error);
            }
            
            // Parse file structure (PNG chunks, JPEG segments, etc.)
            const arrayBuffer = await file.arrayBuffer();
            
            if (file.name.toLowerCase().endsWith('.png')) {
                result.chunks = await parsePngChunks(arrayBuffer);
                result.pngTextChunks = extractPngTextChunks(result.chunks);
                
                // Calculate structure data
                result.structure = calculatePngStructure(result.chunks, file.size);
            } else if (file.type === 'image/jpeg' || file.name.toLowerCase().endsWith('.jpg')) {
                result.chunks = await parseJpegSegments(arrayBuffer);
                
                // Calculate structure data for JPEG
                result.structure = calculateJpegStructure(result.chunks, file.size);
            }
            
            // Detect AI metadata
            result.aiMetadata = detectAIMetadata(result);
            
            // Determine provenance
            result.provenance = determineProvenance(result);
            
            // Calculate anomalies
            result.anomalies = calculateAnomalies(result);
            
            return result;
        }
        
        // PNG chunk parser
        async function parsePngChunks(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const chunks = [];
            
            // Check PNG signature
            if (view.getUint32(0) !== 0x89504E47 || view.getUint32(4) !== 0x0D0A1A0A) {
                throw new Error('Not a valid PNG file');
            }
            
            let offset = 8; // Skip PNG signature
            
            while (offset < arrayBuffer.byteLength - 12) {
                const length = view.getUint32(offset);
                offset += 4;
                
                const typeBytes = new Uint8Array(arrayBuffer, offset, 4);
                const chunkType = String.fromCharCode(...typeBytes);
                offset += 4;
                
                const data = new Uint8Array(arrayBuffer, offset, length);
                offset += length;
                
                const crc = view.getUint32(offset);
                offset += 4;
                
                chunks.push({
                    type: chunkType,
                    length: length,
                    data: data,
                    offset: offset - length - 12,
                    crc: crc
                });
                
                if (chunkType === 'IEND') break;
            }
            
            return chunks;
        }
        
        // JPEG segment parser (simplified)
        async function parseJpegSegments(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const segments = [];
            
            let offset = 0;
            
            // Check JPEG signature
            if (view.getUint16(0) !== 0xFFD8) {
                throw new Error('Not a valid JPEG file');
            }
            
            offset = 2;
            
            while (offset < arrayBuffer.byteLength - 4) {
                const marker = view.getUint16(offset);
                
                if ((marker & 0xFF00) !== 0xFF00) break;
                
                offset += 2;
                
                // Markers without length
                if (marker === 0xFFD8 || marker === 0xFFD9 || (marker >= 0xFFD0 && marker <= 0xFFD7)) {
                    segments.push({
                        type: `0x${marker.toString(16).toUpperCase()}`,
                        length: 0,
                        offset: offset - 2
                    });
                    continue;
                }
                
                const length = view.getUint16(offset);
                
                segments.push({
                    type: `0x${marker.toString(16).toUpperCase()}`,
                    typeName: getJpegMarkerName(marker),
                    length: length,
                    offset: offset - 2
                });
                
                offset += length;
            }
            
            return segments;
        }
        
        function getJpegMarkerName(marker) {
            const names = {
                0xFFC0: 'SOF0 (Baseline DCT)',
                0xFFC4: 'DHT (Huffman Table)',
                0xFFD8: 'SOI (Start of Image)',
                0xFFD9: 'EOI (End of Image)',
                0xFFDA: 'SOS (Start of Scan)',
                0xFFDB: 'DQT (Quantization Table)',
                0xFFE0: 'APP0 (JFIF)',
                0xFFE1: 'APP1 (EXIF/XMP)',
                0xFFE2: 'APP2 (ICC Profile)',
                0xFFFE: 'COM (Comment)',
            };
            return names[marker] || 'Unknown';
        }
        
        // Extract text from PNG text chunks
        function extractPngTextChunks(chunks) {
            if (!chunks) return null;
            
            const textChunks = [];
            const decoder = new TextDecoder('utf-8');
            
            console.log('=== Extracting PNG Text Chunks ===');
            console.log('Total chunks:', chunks.length);
            
            for (const chunk of chunks) {
                console.log('Chunk type:', chunk.type, 'length:', chunk.length);
                
                if (chunk.type === 'tEXt' || chunk.type === 'iTXt' || chunk.type === 'zTXt') {
                    try {
                        // Find null terminator (keyword/text separator)
                        let nullIndex = 0;
                        while (nullIndex < chunk.data.length && chunk.data[nullIndex] !== 0) {
                            nullIndex++;
                        }
                        
                        const keyword = decoder.decode(chunk.data.slice(0, nullIndex));
                        let text = '';
                        
                        if (chunk.type === 'tEXt') {
                            text = decoder.decode(chunk.data.slice(nullIndex + 1));
                        } else if (chunk.type === 'iTXt') {
                            // iTXt format: keyword, null, compression flag, compression method, language tag, null, translated keyword, null, text
                            let offset = nullIndex + 1;
                            const compressionFlag = chunk.data[offset];
                            offset += 1; // Skip compression flag
                            offset += 1; // Skip compression method
                            
                            // Skip language tag (find next null)
                            while (offset < chunk.data.length && chunk.data[offset] !== 0) {
                                offset++;
                            }
                            offset++; // Skip the null
                            
                            // Skip translated keyword (find next null)
                            while (offset < chunk.data.length && chunk.data[offset] !== 0) {
                                offset++;
                            }
                            offset++; // Skip the null
                            
                            // Now we have the actual text
                            const textData = chunk.data.slice(offset);
                            
                            // Check if compressed (compressionFlag === 1)
                            if (compressionFlag === 1 && typeof pako !== 'undefined') {
                                try {
                                    const decompressed = pako.inflate(textData);
                                    text = decoder.decode(decompressed);
                                } catch (e) {
                                    console.warn('Failed to decompress iTXt chunk:', e);
                                    text = decoder.decode(textData);
                                }
                            } else {
                                text = decoder.decode(textData);
                            }
                        } else if (chunk.type === 'zTXt') {
                            // zTXt: keyword, null, compression method (1 byte), compressed data
                            const compressionMethod = chunk.data[nullIndex + 1];
                            const compressedData = chunk.data.slice(nullIndex + 2);
                            
                            if (typeof pako !== 'undefined') {
                                try {
                                    const decompressed = pako.inflate(compressedData);
                                    text = decoder.decode(decompressed);
                                } catch (e) {
                                    console.warn('Failed to decompress zTXt chunk:', e);
                                    text = decoder.decode(compressedData);
                                }
                            } else {
                                console.warn('pako not loaded, cannot decompress zTXt chunk');
                                text = decoder.decode(compressedData);
                            }
                        }
                        
                        textChunks.push({ keyword, text, type: chunk.type });
                        console.log('✓ Extracted text chunk:', keyword, 'type:', chunk.type, 'text length:', text.length);
                        if (keyword.toLowerCase().includes('prompt') || keyword.toLowerCase().includes('workflow')) {
                            console.log('  → First 200 chars:', text.substring(0, 200));
                        }
                    } catch (e) {
                        console.warn('Error parsing text chunk:', e);
                    }
                }
            }
            
            return textChunks.length > 0 ? textChunks : null;
        }
        
        // AI metadata detection
        function detectAIMetadata(metadata) {
            const ai = {
                hasComfyUI: false,
                hasStableDiffusion: false,
                model: null,
                prompt: null,
                negativePrompt: null,
                resolvedPrompt: null,
                workflow: null,
                wildcards: [],
                loras: [],
                sampler: null,
                steps: null,
                cfgScale: null,
                seed: null
            };
            
            // Check EXIF software tag
            if (metadata.exif) {
                const software = metadata.exif.Software || metadata.exif.software;
                if (software) {
                    if (typeof software === 'string' && software.toLowerCase().includes('comfy')) {
                        ai.hasComfyUI = true;
                    }
                    if (typeof software === 'string' && software.toLowerCase().includes('stable')) {
                        ai.hasStableDiffusion = true;
                    }
                }
                
                // Check for model in parameters
                const params = metadata.exif.Parameters || metadata.exif.parameters;
                if (params && typeof params === 'string') {
                    const modelMatch = params.match(/Model:\s*([^\n,]+)/i);
                    if (modelMatch) {
                        ai.model = modelMatch[1].trim();
                    }
                }
            }
            
            // Check PNG text chunks for workflow
            if (metadata.pngTextChunks) {
                console.log('=== Detecting AI Metadata ===');
                console.log('Found', metadata.pngTextChunks.length, 'text chunks');
                console.log('Chunk keywords:', metadata.pngTextChunks.map(c => c.keyword).join(', '));
                
                let workflowData = null;
                let originalPrompt = null;
                let promptFromNodes = null;
                
                // First pass: collect all prompts and workflow data
                for (const chunk of metadata.pngTextChunks) {
                    const keyLower = chunk.keyword.toLowerCase();
                    
                    console.log('→ Processing chunk:', chunk.keyword, 'length:', chunk.text.length);
                    
                    // Check for workflow JSON
                    if (keyLower.includes('workflow') || keyLower === 'workflow') {
                        ai.hasComfyUI = true;
                        try {
                            workflowData = JSON.parse(chunk.text);
                            ai.workflow = workflowData;
                            console.log('Parsed workflow JSON');
                        } catch (e) {
                            console.log('Workflow chunk is not JSON');
                        }
                    }
                    
                    // Check for prompt - could be JSON (workflow nodes) or text
                    if (keyLower === 'prompt') {
                        try {
                            const promptData = JSON.parse(chunk.text);
                            if (promptData && typeof promptData === 'object') {
                                // This is workflow nodes JSON
                                if (!workflowData) {
                                    workflowData = promptData;
                                    ai.workflow = workflowData;
                                    ai.hasComfyUI = true;
                                }
                                console.log('Prompt chunk contains workflow nodes JSON');
                            }
                        } catch (e) {
                            // It's a text prompt - this is likely the original with wildcards
                            console.log('Prompt chunk is text:', chunk.text.substring(0, 100));
                            if (!originalPrompt) {
                                originalPrompt = chunk.text;
                            }
                        }
                    }
                    
                    // Check for resolved prompt
                    if (keyLower.includes('resolved') || keyLower === 'prompt_resolved') {
                        ai.resolvedPrompt = chunk.text;
                        console.log('Found resolved prompt');
                    }
                    
                    // Check for negative prompt
                    if (keyLower.includes('negative')) {
                        ai.negativePrompt = chunk.text;
                    }
                }
                
                // Extract data from workflow nodes
                if (workflowData) {
                    console.log('→ Extracting from workflow nodes...');
                    const nodes = workflowData.nodes || workflowData;
                    console.log('  Workflow structure:', typeof nodes, 'Node count:', Object.keys(nodes).length);
                    
                    if (nodes && typeof nodes === 'object') {
                        let nodeCount = 0;
                        for (const [nodeId, node] of Object.entries(nodes)) {
                            if (!node || typeof node !== 'object') continue;
                            
                            if (nodeCount < 2) { // Log first 2 nodes fully
                                console.log('  Node', nodeId, 'FULL OBJECT:', JSON.stringify(node, null, 2).substring(0, 500));
                            }
                            console.log('  Node', nodeId, '- class_type:', node.class_type, '- keys:', Object.keys(node).join(', '));
                            nodeCount++;
                            if (!node || typeof node !== 'object') continue;
                            
                            // Extract data from node inputs (regardless of class_type)
                            if (node.inputs && typeof node.inputs === 'object') {
                                // Extract model
                                if (node.inputs.unet_name && !ai.model) ai.model = node.inputs.unet_name;
                                if (node.inputs.ckpt_name && !ai.model) ai.model = node.inputs.ckpt_name;
                                
                                // Extract sampler settings (if this node has them)
                                if (node.inputs.sampler_name) {
                                    ai.sampler = node.inputs.sampler_name;
                                    ai.steps = node.inputs.steps || ai.steps;
                                    ai.cfgScale = node.inputs.cfg || ai.cfgScale;
                                    ai.seed = node.inputs.seed || ai.seed;
                                }
                                
                                // Extract LoRA
                                if (node.inputs.lora_name) {
                                    if (!ai.loras.includes(node.inputs.lora_name)) {
                                        ai.loras.push(node.inputs.lora_name);
                                    }
                                }
                                
                                // Extract text from positive/negative inputs
                                if (typeof node.inputs.text === 'string' && node.inputs.text.length > 5) {
                                    const isNegative = node.inputs.text.toLowerCase().includes('blurry') || 
                                                      node.inputs.text.toLowerCase().includes('ugly') ||
                                                      node.inputs.text.toLowerCase().includes('bad');
                                    
                                    if (isNegative && !ai.negativePrompt) {
                                        ai.negativePrompt = node.inputs.text;
                                    } else if (!isNegative && !promptFromNodes) {
                                        promptFromNodes = node.inputs.text;
                                    }
                                }
                            }
                            
                            // Also check old method with class_type for compatibility
                            if (node.class_type) {
                                if ((node.class_type === 'UNETLoader' || node.class_type === 'CheckpointLoaderSimple') && node.inputs) {
                                    if (node.inputs.unet_name) ai.model = node.inputs.unet_name;
                                    if (node.inputs.ckpt_name) ai.model = node.inputs.ckpt_name;
                                }
                                
                                if (node.class_type === 'KSampler' && node.inputs) {
                                    ai.sampler = node.inputs.sampler_name || ai.sampler;
                                    ai.steps = node.inputs.steps || ai.steps;
                                    ai.cfgScale = node.inputs.cfg || ai.cfgScale;
                                    ai.seed = node.inputs.seed || ai.seed;
                                }
                                
                                if (node.class_type === 'LoraLoader' && node.inputs && node.inputs.lora_name) {
                                    if (!ai.loras.includes(node.inputs.lora_name)) {
                                        ai.loras.push(node.inputs.lora_name);
                                    }
                                }
                            }
                            
                            // Extract prompts from text encoding nodes (backup if no text chunk)
                            if (node.class_type === 'CLIPTextEncode' && node.inputs && node.inputs.text) {
                                const nodeText = node.inputs.text;
                                if (typeof nodeText === 'string' && nodeText.length > 5) {
                                    // Check if this looks like a negative prompt
                                    const isNegative = nodeText.toLowerCase().includes('blurry') || 
                                                      nodeText.toLowerCase().includes('ugly') ||
                                                      nodeText.toLowerCase().includes('bad quality');
                                    
                                    if (isNegative) {
                                        if (!ai.negativePrompt) ai.negativePrompt = nodeText;
                                    } else {
                                        // This is a positive prompt - save as backup
                                        if (!promptFromNodes) promptFromNodes = nodeText;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Prioritize prompts: original text chunk (with wildcards) > prompt from nodes
                ai.prompt = originalPrompt || promptFromNodes;
                
                // Detect wildcards in prompt
                if (ai.prompt) {
                    const wildcardPattern = /__.*?__/g;
                    const matches = ai.prompt.match(wildcardPattern);
                    if (matches) {
                        ai.wildcards = matches;
                        console.log('Detected wildcards:', matches);
                    }
                }
            }
            
            console.log('AI metadata detected:', ai);
            return ai;
        }
        
        // Determine image provenance
        function determineProvenance(metadata) {
            const hasCamera = metadata.exif && (
                metadata.exif.Make || metadata.exif.Model || 
                metadata.exif.LensModel || metadata.exif.LensMake
            );
            
            const hasAI = metadata.aiMetadata && (
                metadata.aiMetadata.hasComfyUI || 
                metadata.aiMetadata.hasStableDiffusion ||
                metadata.aiMetadata.model
            );
            
            if (hasCamera && !hasAI) return 'camera';
            if (hasAI && !hasCamera) return 'ai';
            if (hasCamera && hasAI) return 'mixed';
            return 'unclear';
        }
        
        function getContainerType(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            const types = {
                'jpg': 'JPEG', 'jpeg': 'JPEG', 'png': 'PNG',
                'gif': 'GIF', 'tiff': 'TIFF', 'tif': 'TIFF',
                'heic': 'HEIC', 'webp': 'WebP'
            };
            return types[ext] || 'Unknown';
        }
        
        // Extract wildcards and their resolutions
        function extractWildcards(originalPrompt, resolvedPrompt) {
            if (!originalPrompt || !resolvedPrompt) return [];
            
            const wildcards = [];
            const wildcardPattern = /__.*?__/g;
            const matches = [];
            let match;
            
            // Reset regex lastIndex
            wildcardPattern.lastIndex = 0;
            
            // Find all wildcard patterns
            while ((match = wildcardPattern.exec(originalPrompt)) !== null) {
                matches.push({
                    pattern: match[0],
                    index: match.index
                });
            }
            
            if (matches.length === 0) return [];
            
            // For each wildcard, find its resolved value
            for (let i = 0; i < matches.length; i++) {
                const wildcard = matches[i];
                const beforeWildcard = originalPrompt.substring(0, wildcard.index);
                const nextWildcard = matches[i + 1];
                const afterWildcard = nextWildcard ? 
                    originalPrompt.substring(wildcard.index + wildcard.pattern.length, nextWildcard.index) :
                    originalPrompt.substring(wildcard.index + wildcard.pattern.length);
                
                // Find corresponding text in resolved prompt
                const beforeIndex = resolvedPrompt.indexOf(beforeWildcard);
                if (beforeIndex > -1) {
                    const searchStart = beforeIndex + beforeWildcard.length;
                    const afterIndex = afterWildcard ? resolvedPrompt.indexOf(afterWildcard, searchStart) : resolvedPrompt.length;
                    
                    if (afterIndex > -1) {
                        const resolvedValue = resolvedPrompt.substring(searchStart, afterIndex).trim();
                        if (resolvedValue && resolvedValue !== wildcard.pattern) {
                            wildcards.push({
                                name: wildcard.pattern,
                                resolved: resolvedValue
                            });
                        }
                    }
                }
            }
            
            return wildcards;
        }
        
        // Toggle expandable rows
        function toggleRow(element) {
            const nestedRow = element.nextElementSibling;
            const toggle = element.querySelector('.toggle');
            
            if (nestedRow && nestedRow.classList.contains('nested')) {
                if (nestedRow.style.display === 'none') {
                    nestedRow.style.display = 'table-row';
                    toggle.textContent = '-';
                } else {
                    nestedRow.style.display = 'none';
                    toggle.textContent = '+';
                }
            }
        }
        
        // Create metadata table with expandable rows
        function createMetadataTableHTML(metadata, sectionType = '') {
            const sectionClass = sectionType ? `table-${sectionType}` : '';
            let html = `<table class="metadata-table ${sectionClass}"><tbody>`;
            
            function formatValue(value, key = '') {
                if (value === null || value === undefined) return 'null';
                if (typeof value === 'boolean') return value.toString();
                if (typeof value === 'number') return value.toLocaleString();
                if (typeof value === 'string') {
                    // Unescape Unicode sequences then escape HTML
                    const unescaped = unescapeUnicode(value);
                    const escaped = escapeHtml(unescaped);
                    
                    // Add copy button for long text (>100 chars) or specific keys
                    const needsCopyButton = unescaped.length > 100 || 
                        key.toLowerCase().includes('prompt') || 
                        key.toLowerCase().includes('text');
                    
                    if (needsCopyButton) {
                        const encoded = btoa(unescape(encodeURIComponent(unescaped)));
                        return `${escaped}<br><span class="copy-text-btn" data-text-encoded="${encoded}" style="cursor:pointer; color:#6FC3DF; font-size:10px;">[ Copy ]</span>`;
                    }
                    
                    return escaped;
                }
                if (Array.isArray(value)) {
                    // Check if it's an array of primitives
                    if (value.length === 0) return '[Empty Array]';
                    if (typeof value[0] !== 'object') {
                        return escapeHtml(value.map(v => typeof v === 'string' ? unescapeUnicode(v) : v).join(', '));
                    }
                    return `[Array: ${value.length} items]`;
                }
                return escapeHtml(String(value));
            }
            
            function addRows(obj, prefix = '', depth = 0) {
                if (depth > 3) return; // Limit nesting depth
                
                for (const [key, value] of Object.entries(obj)) {
                    const fullKey = prefix ? `${prefix}.${key}` : key;
                    
                    if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                        // Array of objects - create expandable row
                        html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                        html += `<td>${escapeHtml(fullKey)}</td>`;
                        html += `<td>[Array: ${value.length} items] <span class="toggle">+</span></td>`;
                        html += `</tr>`;
                        html += `<tr class="nested" style="display:none;">`;
                        html += `<td colspan="2" style="padding-left:20px; padding-top:0; padding-bottom:0;">`;
                        html += `<table style="width:100%; margin:0; border-collapse:collapse; font-size:12px;">`;
                        
                        // Add array items
                        value.forEach((item, index) => {
                            if (typeof item === 'object' && item !== null) {
                                const itemKeys = Object.keys(item);
                                html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                                html += `<td>[${index}]</td>`;
                                html += `<td>[Object: ${itemKeys.length} properties] <span class="toggle">+</span></td>`;
                                html += `</tr>`;
                                html += `<tr class="nested" style="display:none;">`;
                                html += `<td colspan="2" style="padding-left:15px;">`;
                                html += `<table style="width:100%; margin:0; border-collapse:collapse; font-size:11px;">`;
                                
                                for (const [itemKey, itemValue] of Object.entries(item)) {
                                    html += `<tr><td>${escapeHtml(itemKey)}</td><td>${formatValue(itemValue, itemKey)}</td></tr>`;
                                }
                                
                                html += `</table></td></tr>`;
                            } else {
                                html += `<tr><td>[${index}]</td><td>${formatValue(item, `[${index}]`)}</td></tr>`;
                            }
                        });
                        
                        html += `</table></td></tr>`;
                    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
                        // Nested object - create expandable row
                        const itemCount = Object.keys(value).length;
                        const isExif = key === 'exif' || key.toLowerCase() === 'exif';
                        
                        if (isExif) {
                            // EXIF expanded by default
                            html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                            html += `<td>${escapeHtml(fullKey)}</td>`;
                            html += `<td>[Object: ${itemCount} properties] <span class="toggle">-</span></td>`;
                            html += `</tr>`;
                            html += `<tr class="nested" style="display:table-row;">`;
                        } else {
                            // Other objects collapsed by default
                            html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                            html += `<td>${escapeHtml(fullKey)}</td>`;
                            html += `<td>[Object: ${itemCount} properties] <span class="toggle">+</span></td>`;
                            html += `</tr>`;
                            html += `<tr class="nested" style="display:none;">`;
                        }
                        
                        html += `<td colspan="2" style="padding-left:20px; padding-top:0; padding-bottom:0;">`;
                        html += `<table style="width:100%; margin:0; border-collapse:collapse; font-size:12px;">`;
                        
                        // Add nested properties
                        for (const [nestedKey, nestedValue] of Object.entries(value)) {
                            const displayKey = nestedKey.replace(/^(EXIF|GPS|Image|Interoperability)\s+/i, '');
                            
                            if (nestedValue && typeof nestedValue === 'object' && !Array.isArray(nestedValue) && depth < 2) {
                                // Another level of nesting
                                const nestedItemCount = Object.keys(nestedValue).length;
                                html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                                html += `<td>${escapeHtml(displayKey)}</td>`;
                                html += `<td>[Object: ${nestedItemCount} properties] <span class="toggle">+</span></td>`;
                                html += `</tr>`;
                                html += `<tr class="nested" style="display:none;">`;
                                html += `<td colspan="2" style="padding-left:15px;">`;
                                html += `<table style="width:100%; margin:0; border-collapse:collapse; font-size:11px;">`;
                                
                                for (const [deepKey, deepValue] of Object.entries(nestedValue)) {
                                    html += `<tr><td>${escapeHtml(deepKey)}</td><td>${formatValue(deepValue, deepKey)}</td></tr>`;
                                }
                                
                                html += `</table></td></tr>`;
                            } else {
                                html += `<tr><td>${escapeHtml(displayKey)}</td><td>${formatValue(nestedValue, displayKey)}</td></tr>`;
                            }
                        }
                        
                        html += `</table></td></tr>`;
                    } else {
                        // Simple value (including simple arrays)
                        html += `<tr><td>${escapeHtml(fullKey)}</td><td>${formatValue(value, fullKey)}</td></tr>`;
                    }
                }
            }
            
            addRows(metadata);
            html += '</tbody></table>';
            return html;
        }
        
        // Display metadata in terminal
        function displayMetadata(metadata) {
            let html = '<div class="output-line success">Metadata extracted successfully</div>';
            
            // Provenance summary
            html += '<div class="provenance-summary">';
            if (metadata.provenance === 'camera') {
                const camera = metadata.exif?.Make || 'Unknown';
                const model = metadata.exif?.Model || '';
                html += `This image has metadata indicating it was taken by a camera.<br>`;
                html += `<strong>Camera:</strong> ${escapeHtml(camera + ' ' + model)}<br>`;
            } else if (metadata.provenance === 'ai') {
                const model = metadata.aiMetadata?.model || 'Unknown AI model';
                html += `This image has AI metadata.<br>`;
                html += `<strong>Model:</strong> ${escapeHtml(model)}<br>`;
            } else {
                html += `Not enough metadata to indicate provenance.<br>`;
            }
            
            if (metadata.gps) {
                html += `<strong>GPS:</strong> <span class="copy-icon" onclick="copyToClipboard('${metadata.gps.formatted}', this)">[ ]</span> ${metadata.gps.formatted}<br>`;
            }
            
            html += `</div>`;
            
            // Summary section
            html += '<div class="metadata-section"><div class="section-title category-structure">Summary</div>';
            const summaryData = {
                fileName: metadata.fileName,
                containerType: metadata.containerType,
                'fileSize (b)': metadata.fileSize,
                'fileSize (MB)': (metadata.fileSize / 1024 / 1024).toFixed(2)
            };
            
            if (metadata.exif) {
                const width = metadata.exif.ImageWidth || metadata.exif.PixelXDimension || metadata.exif['Image ImageWidth'];
                const height = metadata.exif.ImageLength || metadata.exif.PixelYDimension || metadata.exif['Image ImageLength'];
                if (width && height) {
                    summaryData.Dimensions = `${width} x ${height}`;
                }
            }
            
            html += createMetadataTableHTML(summaryData, 'summary');
            html += '</div>';
            
            // Structure section
            if (metadata.structure) {
                html += '<div class="metadata-section" id="section-structure"><div class="section-title category-structure">Structure</div>';
                html += createMetadataTableHTML(metadata.structure, 'structure');
                html += '</div>';
            }
            
            // Declared Metadata (EXIF) section - use expandable rows
            if (metadata.exif && Object.keys(metadata.exif).length > 0) {
                html += '<div class="metadata-section" id="section-metadata"><div class="section-title category-metadata">Declared Metadata</div>';
                html += createMetadataTableHTML({ exif: metadata.exif }, 'metadata');
                html += '</div>';
            }
            
            // ComfyUI Workflow section
            if (metadata.aiMetadata && metadata.aiMetadata.hasComfyUI) {
                html += '<div class="metadata-section" id="section-comfyui"><div class="section-title category-ai">ComfyUI Workflow</div>';
                html += '<table class="metadata-table"><tbody>';
                
                // Debug: Log what we have
                console.log('=== ComfyUI Display Debug ===');
                console.log('aiMetadata:', metadata.aiMetadata);
                console.log('prompt:', metadata.aiMetadata.prompt);
                console.log('model:', metadata.aiMetadata.model);
                console.log('sampler:', metadata.aiMetadata.sampler);
                console.log('steps:', metadata.aiMetadata.steps);
                console.log('cfgScale:', metadata.aiMetadata.cfgScale);
                console.log('seed:', metadata.aiMetadata.seed);
                console.log('loras:', metadata.aiMetadata.loras);
                console.log('wildcards:', metadata.aiMetadata.wildcards);
                console.log('resolvedPrompt:', metadata.aiMetadata.resolvedPrompt);
                console.log('negativePrompt:', metadata.aiMetadata.negativePrompt);
                
                // Use data from metadata.aiMetadata (already extracted)
                const model = metadata.aiMetadata.model;
                const sampler = metadata.aiMetadata.sampler;
                const steps = metadata.aiMetadata.steps;
                const cfgScale = metadata.aiMetadata.cfgScale;
                const seed = metadata.aiMetadata.seed;
                const loras = metadata.aiMetadata.loras || [];
                
                // Display all fields directly (no collapsing)
                if (model) html += `<tr><td>Model</td><td>${escapeHtml(model)}</td></tr>`;
                if (loras.length > 0) html += `<tr><td>LoRA</td><td>${escapeHtml(loras.join(', '))}</td></tr>`;
                if (sampler) html += `<tr><td>Sampler</td><td class="category-ai">${escapeHtml(sampler)}</td></tr>`;
                if (steps) html += `<tr><td>Steps</td><td class="category-ai">${steps}</td></tr>`;
                if (cfgScale) html += `<tr><td>CFG Scale</td><td>${cfgScale}</td></tr>`;
                if (seed) html += `<tr><td>Seed</td><td>${seed}</td></tr>`;
                
                // Display prompt with copy button
                if (metadata.aiMetadata.prompt) {
                    const promptText = unescapeUnicode(metadata.aiMetadata.prompt);
                    const promptEncoded = btoa(unescape(encodeURIComponent(promptText)));
                    html += `<tr><td>Prompt</td><td>${escapeHtml(promptText)}<br><span class="copy-text-btn" data-text-encoded="${promptEncoded}" style="cursor:pointer; color:#6FC3DF; font-size:10px;">[ Copy ]</span></td></tr>`;
                }
                
                // Count wildcards
                const wildcardCount = metadata.aiMetadata.wildcards ? metadata.aiMetadata.wildcards.length : 0;
                html += `<tr><td>Wildcards Used</td><td>${wildcardCount}</td></tr>`;
                
                const resolvedPrompt = metadata.aiMetadata.resolvedPrompt;
                html += `<tr><td>Wildcard result</td><td>${resolvedPrompt ? 'resolution saved' : 'resolution not saved'}</td></tr>`;
                
                // Display resolved prompt if available
                if (resolvedPrompt) {
                    const resolvedText = unescapeUnicode(resolvedPrompt);
                    const resolvedEncoded = btoa(unescape(encodeURIComponent(resolvedText)));
                    html += `<tr><td>Resolved Prompt</td><td>${escapeHtml(resolvedText)}<br><span class="copy-text-btn" data-text-encoded="${resolvedEncoded}" style="cursor:pointer; color:#6FC3DF; font-size:10px;">[ Copy ]</span></td></tr>`;
                    
                    // Extract and display wildcard resolutions
                    if (metadata.aiMetadata.prompt && wildcardCount > 0) {
                        const wildcards = extractWildcards(metadata.aiMetadata.prompt, resolvedPrompt);
                        if (wildcards.length > 0) {
                            html += `<tr><td colspan="2" style="padding-top: 10px; font-weight: bold; color: #6FC3DF;">Wildcard Resolutions</td></tr>`;
                            for (const wc of wildcards) {
                                const wcResolved = unescapeUnicode(wc.resolved);
                                html += `<tr><td style="padding-left: 20px;">${escapeHtml(wc.name)}</td><td>${escapeHtml(wcResolved)}</td></tr>`;
                            }
                        }
                    }
                }
                
                // Display negative prompt if available
                if (metadata.aiMetadata.negativePrompt) {
                    const negPromptText = unescapeUnicode(metadata.aiMetadata.negativePrompt);
                    const negPromptEncoded = btoa(unescape(encodeURIComponent(negPromptText)));
                    html += `<tr><td>Negative Prompt</td><td>${escapeHtml(negPromptText)}<br><span class="copy-text-btn" data-text-encoded="${negPromptEncoded}" style="cursor:pointer; color:#6FC3DF; font-size:10px;">[ Copy ]</span></td></tr>`;
                }
                
                // Display nodes count if available
                if (metadata.aiMetadata.workflow) {
                    const nodes = metadata.aiMetadata.workflow.nodes || metadata.aiMetadata.workflow;
                    const nodeCount = Object.keys(nodes).length;
                    html += `<tr><td>Nodes</td><td>${nodeCount} nodes</td></tr>`;
                }
                
                html += '</tbody></table></div>';
            }
            
            // Encryption and AI section (for non-ComfyUI AI metadata)
            if (metadata.aiMetadata && !metadata.aiMetadata.hasComfyUI && (metadata.aiMetadata.model || metadata.aiMetadata.prompt)) {
                html += '<div class="metadata-section" id="section-ai"><div class="section-title category-ai">Encryption and AI</div>';
                
                const aiData = {};
                if (metadata.aiMetadata.model) aiData.Model = metadata.aiMetadata.model;
                if (metadata.aiMetadata.prompt) aiData.Prompt = metadata.aiMetadata.prompt;
                if (metadata.aiMetadata.sampler) aiData.Sampler = metadata.aiMetadata.sampler;
                if (metadata.aiMetadata.steps) aiData.Steps = metadata.aiMetadata.steps;
                if (metadata.aiMetadata.seed) aiData.Seed = metadata.aiMetadata.seed;
                
                html += createMetadataTableHTML(aiData, 'ai');
                html += '</div>';
            }
            
            // Anomalies section
            if (metadata.anomalies) {
                html += '<div class="metadata-section" id="section-anomalies"><div class="section-title category-anomaly">Anomalies</div>';
                html += createMetadataTableHTML(metadata.anomalies, 'anomaly');
                html += '</div>';
            }
            
            // Data Recap section
            html += '<div class="metadata-section"><div class="section-title">Data Recap</div>';
            html += createDataRecap(metadata);
            html += '</div>';
            
            // Bottom raw data display
            html += '<div class="metadata-section"><div class="section-title">Full Object Display</div>';
            html += '<p class="info" style="margin-bottom: 10px;">All extracted data in structured format:</p>';
            html += createMetadataTableHTML({
                summary: metadata.fileName ? { fileName: metadata.fileName, fileSize: metadata.fileSize, containerType: metadata.containerType } : null,
                structure: metadata.structure,
                metadata: metadata.exif ? { exif: metadata.exif } : null,
                aiMetadata: metadata.aiMetadata,
                anomalies: metadata.anomalies,
                provenance: metadata.provenance
            }, 'payload');
            html += '</div>';
            
            output.innerHTML = html;
        }
        
        // Create Data Recap section
        function createDataRecap(metadata) {
            const checks = [
                { name: 'Camera data', found: metadata.exif && (metadata.exif.Make || metadata.exif.Model), section: 'section-metadata' },
                { name: 'Geo data', found: metadata.gps, section: 'section-metadata' },
                { name: 'EXIF', found: metadata.exif && Object.keys(metadata.exif).length > 0, section: 'section-metadata' },
                { name: 'IPTC', found: metadata.exif && metadata.exif.iptc, section: 'section-metadata' },
                { name: 'XMP', found: metadata.exif && metadata.exif.xmp, section: 'section-metadata' },
                { name: 'ComfyUI workflow JSON', found: metadata.aiMetadata?.hasComfyUI, section: 'section-comfyui' },
                { name: 'AI metadata', found: metadata.aiMetadata?.hasComfyUI || metadata.aiMetadata?.hasStableDiffusion, section: 'section-comfyui' },
                { name: 'Wildcards', found: metadata.aiMetadata?.wildcards && metadata.aiMetadata.wildcards.length > 0, section: 'section-comfyui' },
                { name: 'Resolved prompt', found: metadata.aiMetadata?.resolvedPrompt, section: 'section-comfyui' },
                { name: 'Structure data', found: metadata.structure, section: 'section-structure' },
                { name: 'Anomalies', found: metadata.anomalies && metadata.anomalies.flags && metadata.anomalies.flags.length > 0, section: 'section-anomalies' }
            ];
            
            let html = '<div class="data-recap">';
            
            for (const check of checks) {
                if (check.found) {
                    html += `<span class="recap-item">${escapeHtml(check.name)}: <span class="found" onclick="scrollToSection('${check.section}')" title="Click to jump to section">found</span></span> `;
                } else {
                    html += `<span class="recap-item">${escapeHtml(check.name)}: <span class="not-found">not found</span></span> `;
                }
            }
            
            html += '</div>';
            return html;
        }
        
        // Scroll to section with highlight
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                section.classList.add('section-highlight');
                setTimeout(() => {
                    section.classList.remove('section-highlight');
                }, 2000);
            }
        }
        
        // Chunks visualization
        function updateChunksVisualization(chunks, file) {
            if (!chunks || chunks.length === 0) return;
            
            const container = document.getElementById('chunksVisualization');
            let html = '';
            
            // Heatmap
            html += '<div class="heatmap-container">';
            html += '<h3>File Structure Heatmap</h3>';
            html += '<div class="heatmap">';
            
            const colors = {
                'IHDR': '#FF6AC1', 'IDAT': '#6FC3DF', 'IEND': '#3fb950',
                'tEXt': '#7EE787', 'iTXt': '#7EE787', 'zTXt': '#7EE787',
                'gAMA': '#FFA657', 'cHRM': '#FFA657', 'sRGB': '#FFA657',
                'iCCP': '#F778BA', 'pHYs': '#8b949e',
            };
            
            for (const chunk of chunks) {
                const color = colors[chunk.type] || '#30363d';
                const percent = (chunk.length / file.size * 100).toFixed(2);
                html += `<div class="heatmap-segment" style="width: ${percent}%; background: ${color};" title="${chunk.type}: ${chunk.length} bytes"></div>`;
            }
            
            html += '</div>';
            
            // Legend
            html += '<div class="chunk-legend">';
            const usedTypes = [...new Set(chunks.map(c => c.type))];
            for (const type of usedTypes) {
                const color = colors[type] || '#30363d';
                html += `<div class="legend-item"><div class="legend-color" style="background: ${color};"></div>${type}</div>`;
            }
            html += '</div></div>';
            
            // Chunk list
            html += '<div class="chunk-list"><h3>Chunk Details</h3>';
            chunks.forEach((chunk, i) => {
                html += `<div class="chunk-item">`;
                html += `<strong>${i + 1}.</strong> `;
                html += `Type: <span class="chunk-type-label">${chunk.type}</span> | `;
                html += `Length: ${chunk.length.toLocaleString()} bytes | `;
                html += `Offset: 0x${chunk.offset.toString(16).toUpperCase()}`;
                html += `</div>`;
            });
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        // Export JSON
        function exportJSON() {
            if (!currentMetadata) {
                alert('No metadata to export. Please analyze a file first.');
                return;
            }
            
            const fileName = currentFile.name.replace(/\.[^/.]+$/, "");
            const containerType = currentMetadata.containerType.toLowerCase();
            const exportName = `${fileName}_${containerType}_metadata.json`;
            
            const blob = new Blob([JSON.stringify(currentMetadata, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = exportName;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Copy to clipboard
        function copyToClipboard(text, element) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = element.textContent;
                element.textContent = '[✓]';
                element.classList.add('copied');
                setTimeout(() => {
                    element.textContent = originalText;
                    element.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
            });
        }
        
        // Copy button event delegation
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('copy-text-btn')) {
                const encoded = e.target.getAttribute('data-text-encoded');
                if (encoded) {
                    try {
                        const text = decodeURIComponent(escape(atob(encoded)));
                        copyToClipboard(text, e.target);
                    } catch (err) {
                        console.error('Failed to decode text:', err);
                    }
                }
            }
        });
        
        // Utility functions
        function escapeHtml(text) {
            if (typeof text !== 'string') text = String(text);
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function unescapeUnicode(text) {
            if (typeof text !== 'string') return text;
            // Decode Unicode escape sequences like \u00e8
            return text.replace(/\\u[\dA-F]{4}/gi, match => {
                return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
            });
        }
        
        console.log('$ BareBlocks - Client-side metadata inspector ready');
        console.log('All processing happens in your browser');
        console.log('Files never leave your device');
    </script>
</body>
</html>
