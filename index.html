<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BareBlocks - Metadata Inspector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            background: #0d1117;
            color: #c9d1d9;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .terminal-container {
            width: 100%;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background: #0d1117;
        }
        
        .terminal-header {
            background: #161b22;
            padding: 10px 20px;
            border-bottom: 1px solid #30363d;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .terminal-title-area {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .terminal-title {
            color: #6FC3DF;
            font-weight: bold;
            font-size: 14px;
        }
        
        .thumbnail-container {
            display: none;
            align-items: center;
            max-height: 60px;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #30363d;
        }
        
        .thumbnail-container.visible {
            display: flex;
        }
        
        .thumbnail-container img {
            max-height: 60px;
            max-width: 80px;
            object-fit: contain;
        }
        
        .terminal-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tab-button {
            background: transparent;
            border: 1px solid #30363d;
            color: #8b949e;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            transition: all 0.2s;
            touch-action: manipulation;
        }
        
        .tab-button:hover {
            background: #21262d;
            color: #c9d1d9;
            border-color: #6FC3DF;
        }
        
        .tab-button.active {
            background: #0d1117;
            color: #6FC3DF;
            border-color: #6FC3DF;
        }
        
        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .upload-zone {
            border: 2px dashed #30363d;
            border-radius: 8px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #161b22;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .upload-zone:hover,
        .upload-zone.drag-over {
            border-color: #6FC3DF;
            background: #1c2128;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        #fileInput {
            display: none;
        }
        
        .output-line {
            margin: 5px 0;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .prompt {
            color: #6FC3DF;
        }
        
        .success {
            color: #3fb950;
        }
        
        .error {
            color: #f85149;
        }
        
        .info {
            color: #8b949e;
        }
        
        /* Category colors */
        .category-structure { color: #FF6AC1; }
        .category-metadata { color: #FFA657; }
        .category-payloads { color: #6FC3DF; }
        .category-ai { color: #7EE787; }
        
        /* Copy button */
        .copy-icon, .copy-text-btn {
            cursor: pointer;
            margin-left: 8px;
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            background: #21262d;
            border: 1px solid #30363d;
            font-size: 11px;
            transition: all 0.2s;
            text-align: center;
            font-weight: bold;
            user-select: none;
        }
        
        .copy-icon:hover, .copy-text-btn:hover {
            background: #30363d;
            border-color: #6FC3DF;
            transform: scale(1.05);
        }
        
        .copy-icon:active, .copy-text-btn:active {
            transform: scale(0.95);
        }
        
        .copy-icon.copied {
            background: #3fb950;
            border-color: #3fb950;
        }
        
        /* Metadata tables */
        .metadata-section {
            margin: 10px 0;
            background: #161b22;
            border-radius: 4px;
            padding: 10px;
            border: 1px solid #30363d;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .section-collapse-icon {
            display: none;
            font-size: 14px;
            color: #6FC3DF;
            user-select: none;
            margin-left: 10px;
        }
        
        .section-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
        }
        
        .section-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }
        
        .metadata-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            overflow-x: auto;
            display: block;
        }
        
        .metadata-table tbody {
            display: table;
            width: 100%;
        }
        
        .metadata-table tr {
            border-bottom: 1px solid #21262d;
        }
        
        .metadata-table td {
            padding: 4px 8px;
            vertical-align: top;
        }
        
        .metadata-table td:first-child {
            color: #8b949e;
            width: 35%;
            font-weight: 500;
        }
        
        .metadata-table td:last-child {
            color: #c9d1d9;
            word-break: break-word;
        }
        
        /* Expandable rows */
        .expandable {
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .expandable:hover {
            background: #1c2128;
        }
        
        .toggle {
            display: inline-block;
            color: #6FC3DF;
            font-weight: bold;
            margin-left: 8px;
            user-select: none;
            min-width: 15px;
            text-align: center;
        }
        
        .nested {
            background: #0d1117;
        }
        
        .provenance-summary {
            background: #1c2128;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 10px;
            font-size: 12px;
        }
        
        .found {
            color: #3fb950;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .not-found {
            color: #f85149;
        }
        
        .section-highlight {
            animation: highlight-pulse 2s ease-in-out;
            border: 2px solid #6FC3DF !important;
        }
        
        @keyframes highlight-pulse {
            0%, 100% { 
                background: #161b22; 
                border-color: #6FC3DF;
            }
            50% { 
                background: #1c2128; 
                border-color: #3fb950;
            }
        }
        
        /* Data recap styles */
        .data-recap {
            margin: 6px 0;
            font-size: 11px;
            line-height: 1.5;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .recap-item {
            display: inline-block;
            white-space: nowrap;
        }
        
        /* Category colors for table headers */
        .category-anomaly {
            color: #f85149;
        }
        
        /* Chunks visualization */
        .chunks-container {
            margin: 20px 0;
        }
        
        .heatmap-container {
            background: #161b22;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #30363d;
        }
        
        .heatmap {
            width: 100%;
            height: 40px;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .heatmap-segment {
            height: 100%;
            cursor: pointer;
            transition: opacity 0.2s;
            position: relative;
            min-height: 30px;
        }
        
        .heatmap-segment:hover {
            opacity: 0.8;
        }
        
        .chunk-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
            font-size: 11px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
        
        .chunk-list {
            margin-top: 20px;
        }
        
        .chunk-item {
            background: #1c2128;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 10px;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .chunk-type-label {
            color: #6FC3DF;
            cursor: help;
            text-decoration: underline dotted;
        }
        
        /* Mobile responsive */
        /* Tablet and below (768px) */
        @media (max-width: 768px) {
            .terminal-container {
                min-height: 100vh;
            }
            
            .terminal-header {
                flex-direction: column;
                align-items: stretch;
                padding: 12px 15px;
            }
            
            .terminal-tabs {
                width: 100%;
                flex-direction: row;
                justify-content: space-between;
            }
            
            .tab-button {
                padding: 10px 15px;
                font-size: 13px;
                min-height: 44px;
                flex: 1;
            }
            
            .terminal-content {
                padding: 15px;
            }
            
            .upload-zone {
                padding: 40px 20px;
                min-height: 180px;
            }
            
            .metadata-section {
                margin: 12px 0;
                padding: 12px;
            }
            
            .section-title {
                font-size: 14px;
                padding: 8px 10px;
                cursor: pointer;
                user-select: none;
                background: #0d1117;
                border-radius: 4px;
                transition: background 0.2s;
            }
            
            .section-title:active {
                background: #21262d;
            }
            
            .section-collapse-icon {
                display: inline-block;
            }
            
            /* Make expandable rows easier to tap */
            .expandable {
                min-height: 44px;
            }
            
            .toggle {
                font-size: 16px;
                min-width: 24px;
                padding: 5px;
            }
            
            .metadata-table td:first-child {
                width: 45%;
                font-size: 12px;
            }
            
            .metadata-table td:last-child {
                font-size: 12px;
                word-break: break-word;
                overflow-wrap: break-word;
            }
            
            /* ComfyUI specific mobile styles */
            #section-comfyui .metadata-table td:first-child {
                width: 35%;
                max-width: 120px;
                word-break: break-word;
            }
            
            #section-comfyui .metadata-table td:last-child {
                font-size: 11px;
            }
            
            .copy-icon, .copy-text-btn {
                min-width: 44px;
                min-height: 36px;
                padding: 6px 10px;
                font-size: 11px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
            }
            
            .thumbnail-container img {
                max-width: 60px;
                max-height: 50px;
            }
            
            /* Better spacing for recap items */
            .data-recap {
                gap: 6px;
                font-size: 10px;
            }
            
            .recap-item {
                display: inline-block;
            }
            
            .provenance-summary {
                padding: 12px;
                margin: 8px 0;
            }
        }
        
        /* Mobile devices (480px and below) */
        @media (max-width: 480px) {
            body {
                font-size: 12px;
            }
            
            .terminal-header {
                padding: 10px;
            }
            
            .terminal-content {
                padding: 10px;
            }
            
            .terminal-title {
                font-size: 12px;
            }
            
            .tab-button {
                font-size: 11px;
                padding: 8px 10px;
            }
            
            .metadata-section {
                padding: 10px;
                margin: 10px 0;
            }
            
            .section-title {
                font-size: 13px;
                padding: 6px 8px;
            }
            
            .metadata-table {
                font-size: 11px;
            }
            
            .metadata-table td {
                padding: 6px 4px;
            }
            
            .metadata-table td:first-child {
                width: 50%;
            }
            
            /* ComfyUI specific - narrower label column for more value space */
            #section-comfyui .metadata-table td:first-child {
                width: 30%;
                max-width: 100px;
                font-size: 10px;
                word-break: break-word;
            }
            
            #section-comfyui .metadata-table td:last-child {
                width: 70%;
                font-size: 10px;
            }
            
            /* Stack layout for very small screens on key metadata */
            .provenance-summary table td {
                display: block;
                width: 100% !important;
            }
            
            .provenance-summary table td:first-child {
                font-weight: bold;
                padding-bottom: 2px;
                border-bottom: none;
            }
            
            .provenance-summary table td:last-child {
                padding-top: 2px;
                padding-bottom: 8px;
                border-bottom: 1px solid #21262d;
            }
            
            .data-recap {
                gap: 4px;
                font-size: 10px;
                line-height: 1.4;
            }
            
            .recap-item {
                font-size: 10px;
            }
            
            .upload-zone {
                padding: 30px 15px;
                min-height: 150px;
            }
            
            .upload-icon {
                font-size: 36px;
                margin-bottom: 15px;
            }
        }
        
        /* Very small mobile (360px and below) */
        @media (max-width: 360px) {
            .terminal-tabs {
                flex-direction: column;
                gap: 8px;
            }
            
            .tab-button {
                width: 100%;
                min-height: 40px;
            }
            
            .metadata-table td:first-child {
                width: 55%;
            }
            
            /* ComfyUI gets even narrower label on very small screens */
            #section-comfyui .metadata-table td:first-child {
                width: 28%;
                max-width: 80px;
                font-size: 9px;
                word-break: break-word;
            }
            
            #section-comfyui .metadata-table td:last-child {
                width: 72%;
                font-size: 9px;
            }
            
            .copy-icon, .copy-text-btn {
                margin-left: 4px;
                margin-top: 4px;
                display: block;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .tab-button:hover {
                background: transparent;
            }
            
            .tab-button:active {
                background: #21262d;
                transform: scale(0.98);
            }
            
            button, .copy-icon, .copy-text-btn, .chunk-type-label {
                touch-action: manipulation;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="terminal-header">
            <div class="terminal-title-area">
                <div class="terminal-title">$ BareBlocks - Metadata Inspector</div>
                <div class="thumbnail-container" id="thumbnailContainer">
                    <img id="thumbnailImage" alt="Thumbnail">
                </div>
            </div>
            <div class="terminal-tabs">
                <button class="tab-button active" onclick="switchTab('metadata')">Metadata</button>
                <button class="tab-button" onclick="switchTab('imagetools')">Image Tools</button>
            </div>
        </div>
        
        <div class="terminal-content">
            <!-- Metadata Tab -->
            <div id="metadata-tab" class="tab-content active">
                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon">[   ]</div>
                    <div>Click or drag file here to analyze</div>
                    <div class="info" style="margin-top: 10px; font-size: 11px;">
                        Supports: JPEG, PNG, TIFF, HEIC<br>
                        All processing happens in your browser - files never uploaded
                    </div>
                </div>
                <input type="file" id="fileInput" accept="image/*">
                <div id="output"></div>
            </div>
            
            <!-- Image Tools Tab -->
            <div id="imagetools-tab" class="tab-content">
                <div style="max-width: 1400px; margin: 0 auto;">
                    <h2 class="section-title category-ai" style="margin-bottom: 20px;">Image Merger</h2>
                    <p class="info" style="margin-bottom: 20px;">Merge multiple images into a single one. Everything happening client-side.</p>
                    
                    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                        <!-- Left Panel: Settings -->
                        <div style="flex: 0 0 300px; min-width: 250px;">
                            <div class="metadata-section">
                                <div class="section-title">Settings</div>
                                
                                <div style="padding: 15px;">
                                    <!-- Merge Direction -->
                                    <div style="margin-bottom: 20px;">
                                        <label style="display: block; margin-bottom: 8px; color: #8b949e; font-size: 12px;">Merge Direction</label>
                                        <div style="display: flex; gap: 8px;">
                                            <button class="tab-button" id="merge-horizontal" onclick="setMergeDirection('horizontal')" style="flex: 1; font-size: 11px;">→ Horizontal</button>
                                            <button class="tab-button" id="merge-vertical" onclick="setMergeDirection('vertical')" style="flex: 1; font-size: 11px;">↓ Vertical</button>
                                            <button class="tab-button active" id="merge-grid" onclick="setMergeDirection('grid')" style="flex: 1; font-size: 11px;">⊞ Grid</button>
                                        </div>
                                    </div>
                                    
                                    <!-- Grid Columns (only for grid mode) -->
                                    <div id="grid-columns-container" style="margin-bottom: 20px;">
                                        <label style="display: block; margin-bottom: 8px; color: #8b949e; font-size: 12px;">Grid Columns: <span id="grid-columns-value">2</span></label>
                                        <input type="range" id="grid-columns" min="1" max="6" value="2" style="width: 100%;" onchange="updateGridColumns(this.value)">
                                    </div>
                                    
                                    <!-- Image Fit -->
                                    <div style="margin-bottom: 20px;">
                                        <label style="display: block; margin-bottom: 8px; color: #8b949e; font-size: 12px;">Image Fit</label>
                                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                            <button class="tab-button" id="fit-cover" onclick="setImageFit('cover')" style="flex: 1; font-size: 10px;" title="Scales image to cover entire cell (may crop edges)">Cover</button>
                                            <button class="tab-button active" id="fit-contain" onclick="setImageFit('contain')" style="flex: 1; font-size: 10px;" title="Scales image to fit within cell (maintains aspect ratio, adds padding)">Contain</button>
                                            <button class="tab-button" id="fit-fill" onclick="setImageFit('fill')" style="flex: 1; font-size: 10px;" title="Stretches image to fill entire cell (may distort)">Fill</button>
                                            <button class="tab-button" id="fit-scale" onclick="setImageFit('scale')" style="flex: 1; font-size: 10px;" title="Like Contain, but won't enlarge small images">Scale Down</button>
                                        </div>
                                        <p style="margin-top: 8px; font-size: 10px; color: #6FC3DF; line-height: 1.4;" id="fit-description">
                                            Scales to fit within cell, maintains aspect ratio
                                        </p>
                                    </div>
                                    
                                    <!-- Output Dimensions Display -->
                                    <div id="output-dimensions" style="margin-bottom: 15px; padding: 10px; background: #161b22; border-radius: 4px; font-size: 11px; color: #8b949e; display: none;">
                                        <strong style="color: #c9d1d9;">Final Size:</strong> <span id="dimensions-text"></span>
                                    </div>
                                    
                                    <!-- Empty Cells Section -->
                                    <div style="margin-bottom: 20px; padding: 12px; background: #161b22; border-radius: 4px; border: 1px solid #30363d;">
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 12px;">
                                            <input type="checkbox" id="include-empty-cells" onchange="toggleEmptyCells(this.checked)" style="cursor: pointer;">
                                            <span style="color: #c9d1d9; font-size: 12px; font-weight: bold;">Include Empty Cells</span>
                                        </label>
                                        <div id="empty-cells-options" style="display: none;">
                                            <label style="display: block; margin-bottom: 8px; color: #8b949e; font-size: 11px;">Pattern</label>
                                            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                                <button class="tab-button" id="pattern-before" onclick="setEmptyCellPattern('before')" style="flex: 1; font-size: 10px;">Before Each</button>
                                                <button class="tab-button active" id="pattern-after" onclick="setEmptyCellPattern('after')" style="flex: 1; font-size: 10px;">After Each</button>
                                            </div>
                                            <label style="display: block; margin-bottom: 8px; color: #8b949e; font-size: 11px;">Cell Color</label>
                                            <div style="display: flex; gap: 8px;">
                                                <input type="color" id="empty-cell-color" value="#ffffff" onchange="setEmptyCellColor(this.value)" style="width: 50px; height: 32px; cursor: pointer; border: 1px solid #30363d; border-radius: 4px; background: transparent;">
                                                <input type="text" id="empty-cell-color-text" value="#ffffff" onchange="setEmptyCellColor(this.value)" style="flex: 1; padding: 6px; background: #0d1117; border: 1px solid #30363d; border-radius: 4px; color: #c9d1d9; font-size: 11px; font-family: monospace;">
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Text Overlay Section -->
                                    <div style="padding: 15px; background: #161b22; border-radius: 4px; border: 1px solid #30363d; text-align: center;">
                                        <div style="color: #6FC3DF; font-size: 13px; font-weight: bold; margin-bottom: 10px;">✏️ Text Editing</div>
                                        <p style="color: #8b949e; font-size: 11px; line-height: 1.6; margin: 0;">
                                            <strong style="color: #c9d1d9;">Click</strong> any text to edit<br>
                                            <strong style="color: #c9d1d9;">Drag</strong> text to reposition<br>
                                            <strong style="color: #c9d1d9;">Double-click</strong> empty area to add more images
                                        </p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Selected Images List -->
                            <div id="selected-images-list" style="margin-top: 15px;"></div>
                        </div>
                        
                        <!-- Right Panel: Preview + Upload -->
                        <div style="flex: 1; min-width: 400px;">
                            <div class="metadata-section" style="min-height: 500px;">
                                <div class="section-title">Preview & Upload</div>
                                <div id="merge-preview-container" class="upload-zone" style="padding: 20px; text-align: center; min-height: 450px; cursor: pointer; position: relative;">
                                    <input type="file" id="mergeFileInput" accept="image/*" multiple style="display: none;">
                                    <div id="merge-preview" style="width: 100%; min-height: 410px; display: flex; align-items: center; justify-content: center;">
                                        <div style="text-align: center;">
                                            <div class="upload-icon" style="font-size: 48px; margin-bottom: 20px;">[   ]</div>
                                            <div style="font-size: 14px; color: #c9d1d9; margin-bottom: 10px;">Click or drag files here to merge</div>
                                            <div class="info" style="font-size: 11px;">
                                                Supports: JPEG, PNG, TIFF, HEIC<br>
                                                All processing happens in your browser
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Merge Button -->
                            <button class="tab-button" id="merge-download-btn" onclick="downloadMergedImage()" style="width: 100%; margin-top: 15px; padding: 12px; font-size: 14px; display: none;">
                                ⬇ Merge & Download
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Text Edit Modal -->
    <div id="text-edit-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.7); z-index: 10000; align-items: center; justify-content: center;">
        <div id="modal-content" style="background: #161b22; border: 2px solid #6FC3DF; border-radius: 8px; padding: 20px; width: 600px; max-width: 90%; position: relative; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
            <div id="modal-header" style="cursor: move; padding: 10px; margin: -20px -20px 15px -20px; background: #0d1117; border-bottom: 1px solid #30363d; border-radius: 6px 6px 0 0; user-select: none;">
                <h3 style="margin: 0; color: #6FC3DF; font-size: 14px;">✏️ Edit Text</h3>
            </div>
            
            <!-- Text Input -->
            <textarea id="modal-text-input" style="width: 100%; min-height: 100px; padding: 12px; background: #0d1117; border: 1px solid #30363d; border-radius: 4px; color: #c9d1d9; font-family: 'Courier New', monospace; font-size: 13px; resize: vertical; margin-bottom: 15px;" placeholder="Enter text..."></textarea>
            
            <!-- Styling Controls -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label style="display: block; margin-bottom: 6px; color: #8b949e; font-size: 11px;">Font</label>
                    <select id="modal-text-font" style="width: 100%; padding: 6px; background: #0d1117; border: 1px solid #30363d; border-radius: 4px; color: #c9d1d9; font-size: 11px; cursor: pointer;">
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="Courier New, monospace">Courier New</option>
                        <option value="Times New Roman, serif">Times New Roman</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 6px; color: #8b949e; font-size: 11px;">Size: <span id="modal-text-size-value">48</span>px</label>
                    <input type="range" id="modal-text-size" min="12" max="120" value="48" style="width: 100%;">
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label style="display: block; margin-bottom: 6px; color: #8b949e; font-size: 11px;">Color</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="color" id="modal-text-color" value="#ffffff" style="width: 50px; height: 32px; cursor: pointer; border: 1px solid #30363d; border-radius: 4px; background: transparent;">
                        <input type="text" id="modal-text-color-text" value="#ffffff" style="flex: 1; padding: 6px; background: #0d1117; border: 1px solid #30363d; border-radius: 4px; color: #c9d1d9; font-size: 11px; font-family: monospace;">
                    </div>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 6px; color: #8b949e; font-size: 11px;">Opacity: <span id="modal-text-opacity-value">100</span>%</label>
                    <input type="range" id="modal-text-opacity" min="0" max="100" value="100" style="width: 100%;">
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeTextModal(false)" style="padding: 8px 16px; background: #21262d; border: 1px solid #30363d; border-radius: 4px; color: #8b949e; cursor: pointer; font-size: 12px;">Cancel</button>
                <button onclick="closeTextModal(true)" style="padding: 8px 16px; background: #238636; border: 1px solid #2ea043; border-radius: 4px; color: #fff; cursor: pointer; font-size: 12px; font-weight: bold;">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Load exifr library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/exifr@latest/dist/full.umd.js"></script>
    
    <!-- Load pako for zlib decompression -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    
    <script>
        // Global state
        let currentFile = null;
        let currentMetadata = null;
        
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
            
            // Reset image merger if switching away
            if (tabName !== 'imagetools') {
                // Keep merger state
            }
        }
        
        // File upload handling
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const output = document.getElementById('output');
        
        uploadZone.addEventListener('click', () => fileInput.click());
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('drag-over');
        });
        
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('drag-over');
        });
        
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                processFile(e.dataTransfer.files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        });
        
        // Main file processing function
        async function processFile(file) {
            currentFile = file;
            output.innerHTML = '<div class="output-line"><span class="prompt">$</span> Analyzing file...</div>';
            
            try {
                // Show thumbnail
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        document.getElementById('thumbnailImage').src = e.target.result;
                        document.getElementById('thumbnailContainer').classList.add('visible');
                    };
                    reader.readAsDataURL(file);
                } else {
                    document.getElementById('thumbnailContainer').classList.remove('visible');
                }
                
                // Extract metadata
                const metadata = await extractMetadata(file);
                currentMetadata = metadata;
                
                // Cache metadata for potential use in Image Merger
                imageMetadataCache.set(file.name, {
                    metadata: metadata,
                    file: file,
                    timestamp: Date.now()
                });
                console.log(`Cached metadata for: ${file.name}`);
                
                // Display results
                displayMetadata(metadata);
                
                // Update chunks visualization
                if (metadata.chunks) {
                    updateChunksVisualization(metadata.chunks, file);
                }
                
            } catch (error) {
                output.innerHTML += `<div class="output-line error">Error: ${error.message}</div>`;
                console.error('Processing error:', error);
            }
        }
        
        // Calculate PNG structure data
        function calculatePngStructure(chunks, totalSize) {
            if (!chunks || chunks.length === 0) return null;
            
            let pixelDataBytes = 0;
            let nonPixelBytes = 8; // PNG signature
            
            // Calculate bytes for each chunk type
            for (const chunk of chunks) {
                const chunkTotalSize = chunk.length + 12; // length (4) + type (4) + data + crc (4)
                
                if (chunk.type === 'IDAT') {
                    pixelDataBytes += chunkTotalSize;
                } else {
                    nonPixelBytes += chunkTotalSize;
                }
            }
            
            return {
                format: 'PNG',
                totalChunks: chunks.length,
                pixelDataBytes: pixelDataBytes,
                nonPixelBytes: nonPixelBytes,
                nonPixelRatio: (nonPixelBytes / totalSize).toFixed(4),
                chunks: chunks.map(c => ({
                    type: c.type,
                    offset: c.offset,
                    size: c.length,
                    hasData: c.length > 0
                }))
            };
        }
        
        // Calculate JPEG structure data
        function calculateJpegStructure(segments, totalSize) {
            if (!segments || segments.length === 0) return null;
            
            let pixelDataBytes = 0;
            let nonPixelBytes = 0;
            
            for (const segment of segments) {
                if (segment.type === '0xFFDA') { // SOS (Start of Scan) - contains pixel data
                    pixelDataBytes += segment.length || 0;
                } else {
                    nonPixelBytes += (segment.length || 0) + 2; // marker (2 bytes)
                }
            }
            
            return {
                format: 'JPEG',
                totalSegments: segments.length,
                pixelDataBytes: pixelDataBytes,
                nonPixelBytes: nonPixelBytes,
                nonPixelRatio: (nonPixelBytes / totalSize).toFixed(4),
                segments: segments.map(s => ({
                    type: s.type,
                    typeName: s.typeName,
                    offset: s.offset,
                    size: s.length,
                    hasData: (s.length || 0) > 0
                }))
            };
        }
        
        // Calculate anomalies
        function calculateAnomalies(metadata) {
            const anomalies = {
                fileSize: metadata.fileSize,
                pixelDataBytes: metadata.structure?.pixelDataBytes || 0,
                nonPixelBytes: metadata.structure?.nonPixelBytes || 0,
                nonPixelRatio: metadata.structure?.nonPixelRatio || 0,
                flags: []
            };
            
            // Check for custom chunks (PNG)
            if (metadata.chunks) {
                const standardPngChunks = ['IHDR', 'PLTE', 'IDAT', 'IEND', 'tRNS', 'gAMA', 'cHRM', 'sRGB', 'iCCP', 'tEXt', 'zTXt', 'iTXt', 'bKGD', 'pHYs', 'sBIT', 'sPLT', 'hIST', 'tIME'];
                const customChunks = metadata.chunks.filter(c => !standardPngChunks.includes(c.type));
                if (customChunks.length > 0) {
                    anomalies.flags.push('custom_chunks_present');
                }
            }
            
            // Check for high metadata ratio
            if (parseFloat(anomalies.nonPixelRatio) > 0.2) {
                anomalies.flags.push('high_metadata_ratio');
            }
            
            // Check for AI metadata
            if (metadata.aiMetadata?.hasComfyUI || metadata.aiMetadata?.hasStableDiffusion) {
                anomalies.flags.push('ai_metadata_present');
            }
            
            return anomalies;
        }
        
        // Metadata extraction (pure JavaScript)
        async function extractMetadata(file) {
            const result = {
                fileName: file.name,
                fileSize: file.size,
                mimeType: file.type,
                containerType: getContainerType(file),
            };
            
            // Extract EXIF/IPTC/XMP using exifr
            try {
                const exifData = await exifr.parse(file, {
                    tiff: true,
                    exif: true,
                    gps: true,
                    iptc: true,
                    icc: true,
                    jfif: true,
                    ihdr: true,
                    translateKeys: false,
                    translateValues: false,
                    reviveValues: true,
                    sanitize: false,
                    mergeOutput: false,
                });
                
                if (exifData) {
                    result.exif = exifData;
                }
                
                // GPS coordinates
                const gps = await exifr.gps(file);
                if (gps) {
                    result.gps = {
                        latitude: gps.latitude,
                        longitude: gps.longitude,
                        formatted: `${gps.latitude}, ${gps.longitude}`
                    };
                }
                
            } catch (error) {
                console.warn('EXIF extraction error:', error);
            }
            
            // Parse file structure (PNG chunks, JPEG segments, etc.)
            const arrayBuffer = await file.arrayBuffer();
            
            if (file.name.toLowerCase().endsWith('.png')) {
                result.chunks = await parsePngChunks(arrayBuffer);
                result.pngTextChunks = extractPngTextChunks(result.chunks);
                
                // Calculate structure data
                result.structure = calculatePngStructure(result.chunks, file.size);
            } else if (file.type === 'image/jpeg' || file.name.toLowerCase().endsWith('.jpg')) {
                result.chunks = await parseJpegSegments(arrayBuffer);
                
                // Calculate structure data for JPEG
                result.structure = calculateJpegStructure(result.chunks, file.size);
            }
            
            // Detect AI metadata
            result.aiMetadata = detectAIMetadata(result);
            
            // Determine provenance
            result.provenance = determineProvenance(result);
            
            // Calculate anomalies
            result.anomalies = calculateAnomalies(result);
            
            return result;
        }
        
        // PNG chunk parser
        async function parsePngChunks(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const chunks = [];
            
            // Check PNG signature
            if (view.getUint32(0) !== 0x89504E47 || view.getUint32(4) !== 0x0D0A1A0A) {
                throw new Error('Not a valid PNG file');
            }
            
            let offset = 8; // Skip PNG signature
            
            while (offset < arrayBuffer.byteLength - 12) {
                const length = view.getUint32(offset);
                offset += 4;
                
                const typeBytes = new Uint8Array(arrayBuffer, offset, 4);
                const chunkType = String.fromCharCode(...typeBytes);
                offset += 4;
                
                const data = new Uint8Array(arrayBuffer, offset, length);
                offset += length;
                
                const crc = view.getUint32(offset);
                offset += 4;
                
                chunks.push({
                    type: chunkType,
                    length: length,
                    data: data,
                    offset: offset - length - 12,
                    crc: crc
                });
                
                if (chunkType === 'IEND') break;
            }
            
            return chunks;
        }
        
        // JPEG segment parser (simplified)
        async function parseJpegSegments(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const segments = [];
            
            let offset = 0;
            
            // Check JPEG signature
            if (view.getUint16(0) !== 0xFFD8) {
                throw new Error('Not a valid JPEG file');
            }
            
            offset = 2;
            
            while (offset < arrayBuffer.byteLength - 4) {
                const marker = view.getUint16(offset);
                
                if ((marker & 0xFF00) !== 0xFF00) break;
                
                offset += 2;
                
                // Markers without length
                if (marker === 0xFFD8 || marker === 0xFFD9 || (marker >= 0xFFD0 && marker <= 0xFFD7)) {
                    segments.push({
                        type: `0x${marker.toString(16).toUpperCase()}`,
                        length: 0,
                        offset: offset - 2
                    });
                    continue;
                }
                
                const length = view.getUint16(offset);
                
                segments.push({
                    type: `0x${marker.toString(16).toUpperCase()}`,
                    typeName: getJpegMarkerName(marker),
                    length: length,
                    offset: offset - 2
                });
                
                offset += length;
            }
            
            return segments;
        }
        
        function getJpegMarkerName(marker) {
            const names = {
                0xFFC0: 'SOF0 (Baseline DCT)',
                0xFFC4: 'DHT (Huffman Table)',
                0xFFD8: 'SOI (Start of Image)',
                0xFFD9: 'EOI (End of Image)',
                0xFFDA: 'SOS (Start of Scan)',
                0xFFDB: 'DQT (Quantization Table)',
                0xFFE0: 'APP0 (JFIF)',
                0xFFE1: 'APP1 (EXIF/XMP)',
                0xFFE2: 'APP2 (ICC Profile)',
                0xFFFE: 'COM (Comment)',
            };
            return names[marker] || 'Unknown';
        }
        
        // Extract text from PNG text chunks
        function extractPngTextChunks(chunks) {
            if (!chunks) return null;
            
            const textChunks = [];
            const decoder = new TextDecoder('utf-8');
            
            console.log('=== Extracting PNG Text Chunks ===');
            console.log('Total chunks:', chunks.length);
            
            for (const chunk of chunks) {
                console.log('Chunk type:', chunk.type, 'length:', chunk.length);
                
                if (chunk.type === 'tEXt' || chunk.type === 'iTXt' || chunk.type === 'zTXt') {
                    try {
                        // Find null terminator (keyword/text separator)
                        let nullIndex = 0;
                        while (nullIndex < chunk.data.length && chunk.data[nullIndex] !== 0) {
                            nullIndex++;
                        }
                        
                        const keyword = decoder.decode(chunk.data.slice(0, nullIndex));
                        let text = '';
                        
                        if (chunk.type === 'tEXt') {
                            text = decoder.decode(chunk.data.slice(nullIndex + 1));
                        } else if (chunk.type === 'iTXt') {
                            // iTXt format: keyword, null, compression flag, compression method, language tag, null, translated keyword, null, text
                            let offset = nullIndex + 1;
                            const compressionFlag = chunk.data[offset];
                            offset += 1; // Skip compression flag
                            offset += 1; // Skip compression method
                            
                            // Skip language tag (find next null)
                            while (offset < chunk.data.length && chunk.data[offset] !== 0) {
                                offset++;
                            }
                            offset++; // Skip the null
                            
                            // Skip translated keyword (find next null)
                            while (offset < chunk.data.length && chunk.data[offset] !== 0) {
                                offset++;
                            }
                            offset++; // Skip the null
                            
                            // Now we have the actual text
                            const textData = chunk.data.slice(offset);
                            
                            // Check if compressed (compressionFlag === 1)
                            if (compressionFlag === 1 && typeof pako !== 'undefined') {
                                try {
                                    const decompressed = pako.inflate(textData);
                                    text = decoder.decode(decompressed);
                                } catch (e) {
                                    console.warn('Failed to decompress iTXt chunk:', e);
                                    text = decoder.decode(textData);
                                }
                            } else {
                                text = decoder.decode(textData);
                            }
                        } else if (chunk.type === 'zTXt') {
                            // zTXt: keyword, null, compression method (1 byte), compressed data
                            const compressionMethod = chunk.data[nullIndex + 1];
                            const compressedData = chunk.data.slice(nullIndex + 2);
                            
                            if (typeof pako !== 'undefined') {
                                try {
                                    const decompressed = pako.inflate(compressedData);
                                    text = decoder.decode(decompressed);
                                } catch (e) {
                                    console.warn('Failed to decompress zTXt chunk:', e);
                                    text = decoder.decode(compressedData);
                                }
                            } else {
                                console.warn('pako not loaded, cannot decompress zTXt chunk');
                                text = decoder.decode(compressedData);
                            }
                        }
                        
                        textChunks.push({ keyword, text, type: chunk.type });
                        console.log('✓ Extracted text chunk:', keyword, 'type:', chunk.type, 'text length:', text.length);
                        if (keyword.toLowerCase().includes('prompt') || keyword.toLowerCase().includes('workflow')) {
                            console.log('  → First 200 chars:', text.substring(0, 200));
                        }
                    } catch (e) {
                        console.warn('Error parsing text chunk:', e);
                    }
                }
            }
            
            return textChunks.length > 0 ? textChunks : null;
        }
        
        // AI metadata detection
        function detectAIMetadata(metadata) {
            const ai = {
                hasComfyUI: false,
                hasStableDiffusion: false,
                model: null,
                prompt: null,
                negativePrompt: null,
                resolvedPrompt: null,
                workflow: null,
                wildcards: [],
                loras: [],
                sampler: null,
                steps: null,
                cfgScale: null,
                seed: null
            };
            
            // Check EXIF software tag
            if (metadata.exif) {
                const software = metadata.exif.Software || metadata.exif.software;
                if (software) {
                    if (typeof software === 'string' && software.toLowerCase().includes('comfy')) {
                        ai.hasComfyUI = true;
                    }
                    if (typeof software === 'string' && software.toLowerCase().includes('stable')) {
                        ai.hasStableDiffusion = true;
                    }
                }
                
                // Check for model in parameters
                const params = metadata.exif.Parameters || metadata.exif.parameters;
                if (params && typeof params === 'string') {
                    const modelMatch = params.match(/Model:\s*([^\n,]+)/i);
                    if (modelMatch) {
                        ai.model = modelMatch[1].trim();
                    }
                }
            }
            
            // Check PNG text chunks for workflow
            if (metadata.pngTextChunks) {
                console.log('=== Detecting AI Metadata ===');
                console.log('Found', metadata.pngTextChunks.length, 'text chunks');
                console.log('Chunk keywords:', metadata.pngTextChunks.map(c => c.keyword).join(', '));
                
                let workflowData = null;
                let originalPrompt = null;
                let promptFromNodes = null;
                
                // First pass: collect all prompts and workflow data
                for (const chunk of metadata.pngTextChunks) {
                    const keyLower = chunk.keyword.toLowerCase();
                    
                    console.log('→ Processing chunk:', chunk.keyword, 'length:', chunk.text.length);
                    
                    // Check for prompt FIRST - could be JSON (workflow nodes) or text
                    if (keyLower === 'prompt') {
                        try {
                            const promptData = JSON.parse(chunk.text);
                            if (promptData && typeof promptData === 'object') {
                                // This is workflow nodes JSON - PRIORITIZE THIS!
                                workflowData = promptData;
                                ai.workflow = workflowData;
                                ai.hasComfyUI = true;
                                console.log('✓ Prompt chunk contains workflow nodes JSON - USING THIS');
                            }
                        } catch (e) {
                            // It's a text prompt - this is likely the original with wildcards
                            console.log('Prompt chunk is text:', chunk.text.substring(0, 100));
                            if (!originalPrompt) {
                                originalPrompt = chunk.text;
                            }
                        }
                    }
                    
                    // Check for workflow JSON (but don't overwrite if we have prompt data)
                    if (keyLower.includes('workflow') || keyLower === 'workflow') {
                        ai.hasComfyUI = true;
                        try {
                            const workflowJSON = JSON.parse(chunk.text);
                            // Only use workflow chunk if we don't have prompt chunk data
                            if (!workflowData) {
                                workflowData = workflowJSON;
                                ai.workflow = workflowData;
                                console.log('Parsed workflow JSON (no prompt data yet)');
                            } else {
                                console.log('Skipping workflow chunk - already have prompt data');
                            }
                        } catch (e) {
                            console.log('Workflow chunk is not JSON');
                        }
                    }
                    
                    // Check for resolved prompt
                    if (keyLower.includes('resolved') || keyLower === 'prompt_resolved') {
                        ai.resolvedPrompt = chunk.text;
                        console.log('Found resolved prompt');
                    }
                    
                    // Check for negative prompt
                    if (keyLower.includes('negative')) {
                        ai.negativePrompt = chunk.text;
                    }
                }
                
                // Extract data from workflow nodes
                if (workflowData) {
                    console.log('→ Extracting from workflow nodes...');
                    const nodes = workflowData.nodes || workflowData;
                    console.log('  Workflow structure:', typeof nodes, 'Node count:', Object.keys(nodes).length);
                    
                    if (nodes && typeof nodes === 'object') {
                        let nodeCount = 0;
                        for (const [nodeId, node] of Object.entries(nodes)) {
                            if (!node || typeof node !== 'object') continue;
                            
                            if (nodeCount < 2) { // Log first 2 nodes fully
                                console.log('  Node', nodeId, 'FULL OBJECT:', JSON.stringify(node, null, 2).substring(0, 500));
                            }
                            console.log('  Node', nodeId, '- class_type:', node.class_type, '- keys:', Object.keys(node).join(', '));
                            nodeCount++;
                            if (!node || typeof node !== 'object') continue;
                            
                            // Extract data from node inputs (regardless of class_type)
                            if (node.inputs && typeof node.inputs === 'object') {
                                // Extract model
                                if (node.inputs.unet_name && !ai.model) ai.model = node.inputs.unet_name;
                                if (node.inputs.ckpt_name && !ai.model) ai.model = node.inputs.ckpt_name;
                                
                                // Extract sampler settings (if this node has them)
                                if (node.inputs.sampler_name) {
                                    ai.sampler = node.inputs.sampler_name;
                                    ai.steps = node.inputs.steps || ai.steps;
                                    ai.cfgScale = node.inputs.cfg || ai.cfgScale;
                                    ai.seed = node.inputs.seed || ai.seed;
                                }
                                
                                // Extract LoRA
                                if (node.inputs.lora_name) {
                                    if (!ai.loras.includes(node.inputs.lora_name)) {
                                        ai.loras.push(node.inputs.lora_name);
                                    }
                                }
                                
                                // Extract text from positive/negative inputs
                                if (typeof node.inputs.text === 'string' && node.inputs.text.length > 5) {
                                    const isNegative = node.inputs.text.toLowerCase().includes('blurry') || 
                                                      node.inputs.text.toLowerCase().includes('ugly') ||
                                                      node.inputs.text.toLowerCase().includes('bad');
                                    
                                    if (isNegative && !ai.negativePrompt) {
                                        ai.negativePrompt = node.inputs.text;
                                    } else if (!isNegative && !promptFromNodes) {
                                        promptFromNodes = node.inputs.text;
                                    }
                                }
                            }
                            
                            // Also check old method with class_type for compatibility
                            if (node.class_type) {
                                if ((node.class_type === 'UNETLoader' || node.class_type === 'CheckpointLoaderSimple') && node.inputs) {
                                    if (node.inputs.unet_name) ai.model = node.inputs.unet_name;
                                    if (node.inputs.ckpt_name) ai.model = node.inputs.ckpt_name;
                                }
                                
                                if (node.class_type === 'KSampler' && node.inputs) {
                                    ai.sampler = node.inputs.sampler_name || ai.sampler;
                                    ai.steps = node.inputs.steps || ai.steps;
                                    ai.cfgScale = node.inputs.cfg || ai.cfgScale;
                                    ai.seed = node.inputs.seed || ai.seed;
                                }
                                
                                if (node.class_type === 'LoraLoader' && node.inputs && node.inputs.lora_name) {
                                    if (!ai.loras.includes(node.inputs.lora_name)) {
                                        ai.loras.push(node.inputs.lora_name);
                                    }
                                }
                            }
                            
                            // Extract prompts from text encoding nodes (backup if no text chunk)
                            if (node.class_type === 'CLIPTextEncode' && node.inputs && node.inputs.text) {
                                const nodeText = node.inputs.text;
                                if (typeof nodeText === 'string' && nodeText.length > 5) {
                                    // Check if this looks like a negative prompt
                                    const isNegative = nodeText.toLowerCase().includes('blurry') || 
                                                      nodeText.toLowerCase().includes('ugly') ||
                                                      nodeText.toLowerCase().includes('bad quality');
                                    
                                    if (isNegative) {
                                        if (!ai.negativePrompt) ai.negativePrompt = nodeText;
                                    } else {
                                        // This is a positive prompt - save as backup
                                        if (!promptFromNodes) promptFromNodes = nodeText;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Prioritize prompts: original text chunk (with wildcards) > prompt from nodes
                ai.prompt = originalPrompt || promptFromNodes;
                
                // Detect wildcards in prompt
                if (ai.prompt) {
                    const wildcardPattern = /__.*?__/g;
                    const matches = ai.prompt.match(wildcardPattern);
                    if (matches) {
                        ai.wildcards = matches;
                        console.log('Detected wildcards:', matches);
                    }
                }
            }
            
            console.log('AI metadata detected:', ai);
            return ai;
        }
        
        // Determine image provenance
        function determineProvenance(metadata) {
            const hasCamera = metadata.exif && (
                metadata.exif.Make || metadata.exif.Model || 
                metadata.exif.LensModel || metadata.exif.LensMake
            );
            
            const hasAI = metadata.aiMetadata && (
                metadata.aiMetadata.hasComfyUI || 
                metadata.aiMetadata.hasStableDiffusion ||
                metadata.aiMetadata.model
            );
            
            if (hasCamera && !hasAI) return 'camera';
            if (hasAI && !hasCamera) return 'ai';
            if (hasCamera && hasAI) return 'mixed';
            return 'unclear';
        }
        
        function getContainerType(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            const types = {
                'jpg': 'JPEG', 'jpeg': 'JPEG', 'png': 'PNG',
                'gif': 'GIF', 'tiff': 'TIFF', 'tif': 'TIFF',
                'heic': 'HEIC', 'webp': 'WebP'
            };
            return types[ext] || 'Unknown';
        }
        
        // Extract wildcards and their resolutions
        function extractWildcards(originalPrompt, resolvedPrompt) {
            if (!originalPrompt || !resolvedPrompt) return [];
            
            const wildcards = [];
            const wildcardPattern = /__.*?__/g;
            const matches = [];
            let match;
            
            // Reset regex lastIndex
            wildcardPattern.lastIndex = 0;
            
            // Find all wildcard patterns
            while ((match = wildcardPattern.exec(originalPrompt)) !== null) {
                matches.push({
                    pattern: match[0],
                    index: match.index
                });
            }
            
            if (matches.length === 0) return [];
            
            // For each wildcard, find its resolved value
            for (let i = 0; i < matches.length; i++) {
                const wildcard = matches[i];
                const beforeWildcard = originalPrompt.substring(0, wildcard.index);
                const nextWildcard = matches[i + 1];
                const afterWildcard = nextWildcard ? 
                    originalPrompt.substring(wildcard.index + wildcard.pattern.length, nextWildcard.index) :
                    originalPrompt.substring(wildcard.index + wildcard.pattern.length);
                
                // Find corresponding text in resolved prompt
                const beforeIndex = resolvedPrompt.indexOf(beforeWildcard);
                if (beforeIndex > -1) {
                    const searchStart = beforeIndex + beforeWildcard.length;
                    const afterIndex = afterWildcard ? resolvedPrompt.indexOf(afterWildcard, searchStart) : resolvedPrompt.length;
                    
                    if (afterIndex > -1) {
                        const resolvedValue = resolvedPrompt.substring(searchStart, afterIndex).trim();
                        if (resolvedValue && resolvedValue !== wildcard.pattern) {
                            wildcards.push({
                                name: wildcard.pattern,
                                resolved: resolvedValue
                            });
                        }
                    }
                }
            }
            
            return wildcards;
        }
        
        // Toggle expandable rows
        function toggleRow(element) {
            const nestedRow = element.nextElementSibling;
            const toggle = element.querySelector('.toggle');
            
            if (nestedRow && nestedRow.classList.contains('nested')) {
                if (nestedRow.style.display === 'none') {
                    nestedRow.style.display = 'table-row';
                    toggle.textContent = '-';
                } else {
                    nestedRow.style.display = 'none';
                    toggle.textContent = '+';
                }
            }
        }
        
        // Toggle section collapse/expand (mobile feature)
        function toggleSection(element) {
            // Only work on mobile (768px and below)
            if (window.innerWidth > 768) return;
            
            const section = element.closest('.metadata-section');
            const content = section.querySelector('.section-content');
            const icon = element.querySelector('.section-collapse-icon');
            
            if (content) {
                content.classList.toggle('collapsed');
                if (icon) {
                    icon.textContent = content.classList.contains('collapsed') ? '▼' : '▲';
                }
            }
        }
        
        // Helper to create section wrapper with collapse functionality
        function createSectionHTML(title, content, categoryClass = '', sectionId = '') {
            const idAttr = sectionId ? ` id="${sectionId}"` : '';
            const titleClass = categoryClass ? `section-title ${categoryClass}` : 'section-title';
            
            let html = `<div class="metadata-section"${idAttr}>`;
            html += `<div class="${titleClass}" onclick="toggleSection(this)">`;
            html += `<span>${title}</span>`;
            html += `<span class="section-collapse-icon">▲</span>`;
            html += `</div>`;
            html += `<div class="section-content">${content}</div>`;
            html += `</div>`;
            return html;
        }
        
        // Format wildcard name for display (shorten for mobile)
        function formatWildcardName(name) {
            // Remove common prefixes to save space
            let formatted = name;
            
            // Remove __mklinkwildcards/ prefix if present
            if (formatted.startsWith('__mklinkwildcards/')) {
                formatted = formatted.substring('__mklinkwildcards/'.length);
            }
            
            // Remove leading/trailing underscores (common in wildcard naming)
            formatted = formatted.replace(/^_+|_+$/g, '');
            
            // If still very long (>30 chars), truncate with ellipsis
            if (formatted.length > 30) {
                formatted = formatted.substring(0, 27) + '...';
            }
            
            return formatted;
        }
        
        // Create metadata table with expandable rows
        function createMetadataTableHTML(metadata, sectionType = '') {
            const sectionClass = sectionType ? `table-${sectionType}` : '';
            let html = `<table class="metadata-table ${sectionClass}"><tbody>`;
            
            function formatValue(value, key = '') {
                if (value === null || value === undefined) return 'null';
                if (typeof value === 'boolean') return value.toString();
                if (typeof value === 'number') return value.toLocaleString();
                if (typeof value === 'string') {
                    // Unescape Unicode sequences then escape HTML
                    const unescaped = unescapeUnicode(value);
                    const escaped = escapeHtml(unescaped);
                    
                    // Add copy button for long text (>100 chars) or specific keys
                    const needsCopyButton = unescaped.length > 100 || 
                        key.toLowerCase().includes('prompt') || 
                        key.toLowerCase().includes('text');
                    
                    if (needsCopyButton) {
                        const encoded = btoa(unescape(encodeURIComponent(unescaped)));
                        return `${escaped}<br><span class="copy-text-btn" data-text-encoded="${encoded}" style="cursor:pointer; color:#6FC3DF; font-size:10px;">[ Copy ]</span>`;
                    }
                    
                    return escaped;
                }
                if (Array.isArray(value)) {
                    // Check if it's an array of primitives
                    if (value.length === 0) return '[Empty Array]';
                    if (typeof value[0] !== 'object') {
                        return escapeHtml(value.map(v => typeof v === 'string' ? unescapeUnicode(v) : v).join(', '));
                    }
                    return `[Array: ${value.length} items]`;
                }
                return escapeHtml(String(value));
            }
            
            function addRows(obj, prefix = '', depth = 0) {
                if (depth > 3) return; // Limit nesting depth
                
                for (const [key, value] of Object.entries(obj)) {
                    const fullKey = prefix ? `${prefix}.${key}` : key;
                    
                    if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                        // Array of objects - create expandable row
                        html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                        html += `<td>${escapeHtml(fullKey)}</td>`;
                        html += `<td>[Array: ${value.length} items] <span class="toggle">+</span></td>`;
                        html += `</tr>`;
                        html += `<tr class="nested" style="display:none;">`;
                        html += `<td colspan="2" style="padding-left:20px; padding-top:0; padding-bottom:0;">`;
                        html += `<table style="width:100%; margin:0; border-collapse:collapse; font-size:12px;">`;
                        
                        // Add array items
                        value.forEach((item, index) => {
                            if (typeof item === 'object' && item !== null) {
                                const itemKeys = Object.keys(item);
                                html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                                html += `<td>[${index}]</td>`;
                                html += `<td>[Object: ${itemKeys.length} properties] <span class="toggle">+</span></td>`;
                                html += `</tr>`;
                                html += `<tr class="nested" style="display:none;">`;
                                html += `<td colspan="2" style="padding-left:15px;">`;
                                html += `<table style="width:100%; margin:0; border-collapse:collapse; font-size:11px;">`;
                                
                                for (const [itemKey, itemValue] of Object.entries(item)) {
                                    html += `<tr><td>${escapeHtml(itemKey)}</td><td>${formatValue(itemValue, itemKey)}</td></tr>`;
                                }
                                
                                html += `</table></td></tr>`;
                            } else {
                                html += `<tr><td>[${index}]</td><td>${formatValue(item, `[${index}]`)}</td></tr>`;
                            }
                        });
                        
                        html += `</table></td></tr>`;
                    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
                        // Nested object - create expandable row
                        const itemCount = Object.keys(value).length;
                        const isExif = key === 'exif' || key.toLowerCase() === 'exif';
                        
                        if (isExif) {
                            // EXIF expanded by default
                            html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                            html += `<td>${escapeHtml(fullKey)}</td>`;
                            html += `<td>[Object: ${itemCount} properties] <span class="toggle">-</span></td>`;
                            html += `</tr>`;
                            html += `<tr class="nested" style="display:table-row;">`;
                        } else {
                            // Other objects collapsed by default
                            html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                            html += `<td>${escapeHtml(fullKey)}</td>`;
                            html += `<td>[Object: ${itemCount} properties] <span class="toggle">+</span></td>`;
                            html += `</tr>`;
                            html += `<tr class="nested" style="display:none;">`;
                        }
                        
                        html += `<td colspan="2" style="padding-left:20px; padding-top:0; padding-bottom:0;">`;
                        html += `<table style="width:100%; margin:0; border-collapse:collapse; font-size:12px;">`;
                        
                        // Add nested properties
                        for (const [nestedKey, nestedValue] of Object.entries(value)) {
                            const displayKey = nestedKey.replace(/^(EXIF|GPS|Image|Interoperability)\s+/i, '');
                            
                            if (nestedValue && typeof nestedValue === 'object' && !Array.isArray(nestedValue) && depth < 2) {
                                // Another level of nesting
                                const nestedItemCount = Object.keys(nestedValue).length;
                                html += `<tr class="expandable" onclick="toggleRow(this)" style="cursor: pointer;">`;
                                html += `<td>${escapeHtml(displayKey)}</td>`;
                                html += `<td>[Object: ${nestedItemCount} properties] <span class="toggle">+</span></td>`;
                                html += `</tr>`;
                                html += `<tr class="nested" style="display:none;">`;
                                html += `<td colspan="2" style="padding-left:15px;">`;
                                html += `<table style="width:100%; margin:0; border-collapse:collapse; font-size:11px;">`;
                                
                                for (const [deepKey, deepValue] of Object.entries(nestedValue)) {
                                    html += `<tr><td>${escapeHtml(deepKey)}</td><td>${formatValue(deepValue, deepKey)}</td></tr>`;
                                }
                                
                                html += `</table></td></tr>`;
                            } else {
                                html += `<tr><td>${escapeHtml(displayKey)}</td><td>${formatValue(nestedValue, displayKey)}</td></tr>`;
                            }
                        }
                        
                        html += `</table></td></tr>`;
                    } else {
                        // Simple value (including simple arrays)
                        html += `<tr><td>${escapeHtml(fullKey)}</td><td>${formatValue(value, fullKey)}</td></tr>`;
                    }
                }
            }
            
            addRows(metadata);
            html += '</tbody></table>';
            return html;
        }
        
        // Display metadata in terminal
        function displayMetadata(metadata) {
            let html = '<div class="output-line success">Metadata extracted successfully <span class="copy-text-btn" onclick="exportJSON()" style="cursor:pointer; color:#6FC3DF; margin-left: 15px;">[ Export JSON ]</span></div>';
            
            // Data Recap section - at the very top
            html += '<div class="metadata-section"><div class="section-title">Data Recap</div>';
            html += createDataRecap(metadata);
            html += '</div>';
            
            // Summary section (merged Smart Summary + regular Summary)
            html += '<div class="metadata-section"><div class="section-title category-structure">Summary</div>';
            html += '<table class="metadata-table"><tbody>';
            
            // Always show these core fields first
            html += `<tr><td>fileName</td><td>${escapeHtml(metadata.fileName)}</td></tr>`;
            html += `<tr><td>containerType</td><td><span style="color: #FF6AC1; font-weight: bold;">${metadata.containerType}</span></td></tr>`;
            html += `<tr><td>fileSize (MB)</td><td><span style="color: #FF6AC1; font-weight: bold;">${(metadata.fileSize / 1024 / 1024).toFixed(2)}</span></td></tr>`;
            
            // Flatten EXIF data for easier access
            let allExifData = {};
            if (metadata.exif) {
                allExifData = { ...metadata.exif };
                if (metadata.exif.ifd0) Object.assign(allExifData, metadata.exif.ifd0);
                if (metadata.exif.exif) Object.assign(allExifData, metadata.exif.exif);
                if (metadata.exif.gps) Object.assign(allExifData, metadata.exif.gps);
            }
            
            // Dimensions - ALWAYS show
            let width = allExifData.ImageWidth || allExifData.PixelXDimension || allExifData['Image ImageWidth'] || null;
            let height = allExifData.ImageLength || allExifData.PixelYDimension || allExifData['Image ImageLength'] || null;
            
            if (width && height) {
                html += `<tr><td>Dimensions</td><td>${width} x ${height}</td></tr>`;
            }
            
            // Date Created - ALWAYS show if available
            if (metadata.exif) {
                // Check multiple date fields in order of preference
                let dateCreated = allExifData.DateTime || 
                                 allExifData.DateTimeOriginal || 
                                 allExifData.CreateDate ||
                                 allExifData['306'] || // IFD0 DateTime tag
                                 null;
                
                if (dateCreated) {
                    // Format the date nicely
                    let displayDate = dateCreated;
                    if (dateCreated instanceof Date) {
                        displayDate = dateCreated.toLocaleString();
                    } else if (typeof dateCreated === 'string') {
                        // Try to parse and format common EXIF date formats
                        const dateMatch = dateCreated.match(/^(\d{4}):(\d{2}):(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
                        if (dateMatch) {
                            // Convert EXIF format (YYYY:MM:DD HH:MM:SS) to readable format
                            const [, year, month, day, hour, minute, second] = dateMatch;
                            const date = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
                            displayDate = date.toLocaleString();
                        }
                    }
                    html += `<tr><td>Date Created</td><td>${escapeHtml(String(displayDate))}</td></tr>`;
                }
            }
            
            // Separator line
            html += `<tr><td colspan="2" style="border-top: 1px solid #30363d; padding-top: 8px;"></td></tr>`;
            
            // Adaptive content based on metadata type
            
            // Camera metadata - show if ANY camera data is found (not just if provenance is camera)
            if (metadata.exif) {
                console.log('=== Camera/Lens Detection ===');
                console.log('Flattened EXIF data keys:', Object.keys(allExifData));
                console.log('Model:', allExifData.Model);
                console.log('Make:', allExifData.Make);
                console.log('LensModel:', allExifData.LensModel);
                console.log('Tag 272:', allExifData['272']);
                console.log('Tag 42036:', allExifData['42036']);
                
                // Camera Model (check multiple fields)
                const cameraModel = allExifData.Model || allExifData['272'] || null;
                const cameraMake = allExifData.Make || null;
                
                if (cameraModel || cameraMake) {
                    const camera = [cameraMake, cameraModel].filter(Boolean).join(' ');
                    html += `<tr><td>Camera</td><td><span style="color: #FFA657; font-weight: bold;">${escapeHtml(camera)}</span></td></tr>`;
                    console.log('✓ Displaying camera:', camera);
                }
                
                // Lens Model (check EXIF tag 42036 and other fields)
                const lensModel = allExifData.LensModel || 
                                 allExifData['42036'] || 
                                 allExifData.LensInfo ||
                                 null;
                
                if (lensModel) {
                    html += `<tr><td>Lens</td><td>${escapeHtml(String(lensModel))}</td></tr>`;
                    console.log('✓ Displaying lens:', lensModel);
                }
                
                // Only show detailed camera settings if we have camera data
                if (cameraModel || cameraMake || lensModel) {
                    if (allExifData.FNumber) {
                        html += `<tr><td>Aperture</td><td>f/${allExifData.FNumber}</td></tr>`;
                    }
                    if (allExifData.ExposureTime) {
                        const exposure = allExifData.ExposureTime < 1 ? `1/${Math.round(1/allExifData.ExposureTime)}` : `${allExifData.ExposureTime}`;
                        html += `<tr><td>Shutter Speed</td><td>${exposure}s</td></tr>`;
                    }
                    if (allExifData.ISO || allExifData.ISOSpeedRatings) {
                        const iso = allExifData.ISO || allExifData.ISOSpeedRatings;
                        html += `<tr><td>ISO</td><td>${iso}</td></tr>`;
                    }
                    if (allExifData.FocalLength) {
                        html += `<tr><td>Focal Length</td><td>${allExifData.FocalLength}mm</td></tr>`;
                    }
                }
            }
            
            // AI metadata
            if (metadata.aiMetadata && (metadata.aiMetadata.hasComfyUI || metadata.aiMetadata.hasStableDiffusion)) {
                if (metadata.aiMetadata.model) {
                    html += `<tr><td>AI Model</td><td><span style="color: #7EE787; font-weight: bold;">${escapeHtml(metadata.aiMetadata.model)}</span></td></tr>`;
                }
                if (metadata.aiMetadata.resolvedPrompt) {
                    const resolvedShort = unescapeUnicode(metadata.aiMetadata.resolvedPrompt);
                    const preview = resolvedShort.length > 150 ? resolvedShort.substring(0, 150) + '...' : resolvedShort;
                    html += `<tr><td>Generated Image</td><td><span style="color: #7EE787;">${escapeHtml(preview)}</span></td></tr>`;
                } else if (metadata.aiMetadata.prompt) {
                    const promptShort = unescapeUnicode(metadata.aiMetadata.prompt);
                    const preview = promptShort.length > 150 ? promptShort.substring(0, 150) + '...' : promptShort;
                    html += `<tr><td>Prompt</td><td><span style="color: #7EE787;">${escapeHtml(preview)}</span></td></tr>`;
                }
            }
            
            // GPS metadata
            if (metadata.gps && metadata.gps.formatted) {
                const gpsId = `gps-copy-${Date.now()}`;
                html += `<tr><td>GPS Coordinates</td><td>`;
                html += `<span style="color: #6FC3DF; font-weight: bold;">${escapeHtml(metadata.gps.formatted)}</span>`;
                html += `<span class="copy-icon" onclick="copyGPSCoords('${escapeHtml(metadata.gps.formatted)}', this)" id="${gpsId}" style="margin-left: 10px; cursor: pointer; color: #6FC3DF;" title="Click to copy coordinates">[ Copy ]</span>`;
                html += `</td></tr>`;
            }
            
            html += '</tbody></table></div>';
            
            // ComfyUI Workflow section
            if (metadata.aiMetadata && metadata.aiMetadata.hasComfyUI) {
                html += '<div class="metadata-section" id="section-comfyui"><div class="section-title category-ai">ComfyUI Workflow</div>';
                html += '<table class="metadata-table"><tbody>';
                
                // Debug: Log what we have
                console.log('=== ComfyUI Display Debug ===');
                console.log('aiMetadata:', metadata.aiMetadata);
                console.log('prompt:', metadata.aiMetadata.prompt);
                console.log('model:', metadata.aiMetadata.model);
                console.log('sampler:', metadata.aiMetadata.sampler);
                console.log('steps:', metadata.aiMetadata.steps);
                console.log('cfgScale:', metadata.aiMetadata.cfgScale);
                console.log('seed:', metadata.aiMetadata.seed);
                console.log('loras:', metadata.aiMetadata.loras);
                console.log('wildcards:', metadata.aiMetadata.wildcards);
                console.log('resolvedPrompt:', metadata.aiMetadata.resolvedPrompt);
                console.log('negativePrompt:', metadata.aiMetadata.negativePrompt);
                
                // Use data from metadata.aiMetadata (already extracted)
                const model = metadata.aiMetadata.model;
                const sampler = metadata.aiMetadata.sampler;
                const steps = metadata.aiMetadata.steps;
                const cfgScale = metadata.aiMetadata.cfgScale;
                const seed = metadata.aiMetadata.seed;
                const loras = metadata.aiMetadata.loras || [];
                
                // Display all fields directly (no collapsing)
                if (model) html += `<tr><td>Model</td><td>${escapeHtml(model)}</td></tr>`;
                if (loras.length > 0) html += `<tr><td>LoRA</td><td>${escapeHtml(loras.join(', '))}</td></tr>`;
                if (sampler) html += `<tr><td>Sampler</td><td class="category-ai">${escapeHtml(sampler)}</td></tr>`;
                if (steps) html += `<tr><td>Steps</td><td class="category-ai">${steps}</td></tr>`;
                if (cfgScale) html += `<tr><td>CFG Scale</td><td>${cfgScale}</td></tr>`;
                if (seed) html += `<tr><td>Seed</td><td>${seed}</td></tr>`;
                
                // Display prompt with copy button - HIGHLIGHTED IN GREEN
                if (metadata.aiMetadata.prompt) {
                    const promptText = unescapeUnicode(metadata.aiMetadata.prompt);
                    const promptEncoded = btoa(unescape(encodeURIComponent(promptText)));
                    html += `<tr><td>Prompt</td><td><span style="color: #7EE787;">${escapeHtml(promptText)}</span><br><span class="copy-text-btn" data-text-encoded="${promptEncoded}" style="cursor:pointer; color:#6FC3DF; font-size:10px;">[ Copy ]</span></td></tr>`;
                }
                
                // Count wildcards
                const wildcardCount = metadata.aiMetadata.wildcards ? metadata.aiMetadata.wildcards.length : 0;
                html += `<tr><td>Wildcards Used</td><td>${wildcardCount}</td></tr>`;
                
                const resolvedPrompt = metadata.aiMetadata.resolvedPrompt;
                html += `<tr><td>Wildcard result</td><td>${resolvedPrompt ? 'resolution saved' : 'resolution not saved'}</td></tr>`;
                
                // Display resolved prompt if available - HIGHLIGHTED IN GREEN
                if (resolvedPrompt) {
                    const resolvedText = unescapeUnicode(resolvedPrompt);
                    const resolvedEncoded = btoa(unescape(encodeURIComponent(resolvedText)));
                    html += `<tr><td>Resolved Prompt</td><td><span style="color: #7EE787;">${escapeHtml(resolvedText)}</span><br><span class="copy-text-btn" data-text-encoded="${resolvedEncoded}" style="cursor:pointer; color:#6FC3DF; font-size:10px;">[ Copy ]</span></td></tr>`;
                    
                    // Extract and display wildcard resolutions
                    if (metadata.aiMetadata.prompt && wildcardCount > 0) {
                        const wildcards = extractWildcards(metadata.aiMetadata.prompt, resolvedPrompt);
                        if (wildcards.length > 0) {
                            html += `<tr><td colspan="2" style="padding-top: 10px; font-weight: bold; color: #6FC3DF;">Wildcard Resolutions</td></tr>`;
                            for (const wc of wildcards) {
                                const wcResolved = unescapeUnicode(wc.resolved);
                                const shortName = formatWildcardName(wc.name);
                                html += `<tr><td style="padding-left: 20px;" title="${escapeHtml(wc.name)}">${escapeHtml(shortName)}</td><td>${escapeHtml(wcResolved)}</td></tr>`;
                            }
                        }
                    }
                }
                
                // Display negative prompt if available
                if (metadata.aiMetadata.negativePrompt) {
                    const negPromptText = unescapeUnicode(metadata.aiMetadata.negativePrompt);
                    const negPromptEncoded = btoa(unescape(encodeURIComponent(negPromptText)));
                    html += `<tr><td>Negative Prompt</td><td>${escapeHtml(negPromptText)}<br><span class="copy-text-btn" data-text-encoded="${negPromptEncoded}" style="cursor:pointer; color:#6FC3DF; font-size:10px;">[ Copy ]</span></td></tr>`;
                }
                
                // Display nodes count if available
                if (metadata.aiMetadata.workflow) {
                    const nodes = metadata.aiMetadata.workflow.nodes || metadata.aiMetadata.workflow;
                    const nodeCount = Object.keys(nodes).length;
                    html += `<tr><td>Nodes</td><td>${nodeCount} nodes</td></tr>`;
                }
                
                html += '</tbody></table></div>';
            }
            
            // Encryption and AI section (for non-ComfyUI AI metadata)
            if (metadata.aiMetadata && !metadata.aiMetadata.hasComfyUI && (metadata.aiMetadata.model || metadata.aiMetadata.prompt)) {
                html += '<div class="metadata-section" id="section-ai"><div class="section-title category-ai">Encryption and AI</div>';
                
                const aiData = {};
                if (metadata.aiMetadata.model) aiData.Model = metadata.aiMetadata.model;
                if (metadata.aiMetadata.prompt) aiData.Prompt = metadata.aiMetadata.prompt;
                if (metadata.aiMetadata.sampler) aiData.Sampler = metadata.aiMetadata.sampler;
                if (metadata.aiMetadata.steps) aiData.Steps = metadata.aiMetadata.steps;
                if (metadata.aiMetadata.seed) aiData.Seed = metadata.aiMetadata.seed;
                
                html += createMetadataTableHTML(aiData, 'ai');
                html += '</div>';
            }
            
            // Structure section - MOVED DOWN
            if (metadata.structure) {
                html += '<div class="metadata-section" id="section-structure"><div class="section-title category-structure">Structure</div>';
                html += createMetadataTableHTML(metadata.structure, 'structure');
                html += '</div>';
            }
            
            // Declared Metadata (EXIF) section - MOVED DOWN
            if (metadata.exif && Object.keys(metadata.exif).length > 0) {
                html += '<div class="metadata-section" id="section-metadata"><div class="section-title category-metadata">Declared Metadata</div>';
                html += createMetadataTableHTML({ exif: metadata.exif }, 'metadata');
                html += '</div>';
            }
            
            // Anomalies section
            if (metadata.anomalies) {
                html += '<div class="metadata-section" id="section-anomalies"><div class="section-title category-anomaly">Anomalies</div>';
                html += createMetadataTableHTML(metadata.anomalies, 'anomaly');
                html += '</div>';
            }
            
            // Bottom raw data display
            html += '<div class="metadata-section"><div class="section-title">Full Object Display</div>';
            html += '<p class="info" style="margin-bottom: 10px;">All extracted data in structured format:</p>';
            html += createMetadataTableHTML({
                summary: metadata.fileName ? { fileName: metadata.fileName, fileSize: metadata.fileSize, containerType: metadata.containerType } : null,
                structure: metadata.structure,
                metadata: metadata.exif ? { exif: metadata.exif } : null,
                aiMetadata: metadata.aiMetadata,
                anomalies: metadata.anomalies,
                provenance: metadata.provenance
            }, 'payload');
            html += '</div>';
            
            // File Structure Visualization (Chunks) - at the very bottom
            html += '<div class="metadata-section" style="margin-top: 20px;"><div class="section-title category-structure">File Structure Visualization</div>';
            html += '<div id="chunksVisualizationInline"></div>';
            html += '</div>';
            
            output.innerHTML = html;
            
            // Populate chunks visualization if available
            if (metadata.chunks && currentFile) {
                updateChunksVisualization(metadata.chunks, currentFile);
            }
        }
        
        // Create Data Recap section
        function createDataRecap(metadata) {
            const checks = [
                { name: 'Camera data', found: metadata.exif && (metadata.exif.Make || metadata.exif.Model), section: 'section-metadata' },
                { name: 'Geo data', found: metadata.gps, section: 'section-metadata' },
                { name: 'EXIF', found: metadata.exif && Object.keys(metadata.exif).length > 0, section: 'section-metadata' },
                { name: 'IPTC', found: metadata.exif && metadata.exif.iptc, section: 'section-metadata' },
                { name: 'XMP', found: metadata.exif && metadata.exif.xmp, section: 'section-metadata' },
                { name: 'ComfyUI workflow JSON', found: metadata.aiMetadata?.hasComfyUI, section: 'section-comfyui' },
                { name: 'AI metadata', found: metadata.aiMetadata?.hasComfyUI || metadata.aiMetadata?.hasStableDiffusion, section: 'section-comfyui' },
                { name: 'Wildcards', found: metadata.aiMetadata?.wildcards && metadata.aiMetadata.wildcards.length > 0, section: 'section-comfyui' },
                { name: 'Resolved prompt', found: metadata.aiMetadata?.resolvedPrompt, section: 'section-comfyui' },
                { name: 'Structure data', found: metadata.structure, section: 'section-structure' },
                { name: 'Anomalies', found: metadata.anomalies && metadata.anomalies.flags && metadata.anomalies.flags.length > 0, section: 'section-anomalies' }
            ];
            
            let html = '<div class="data-recap">';
            
            for (const check of checks) {
                if (check.found) {
                    html += `<span class="recap-item">${escapeHtml(check.name)}: <span class="found" onclick="scrollToSection('${check.section}')" title="Click to jump to section">found</span></span> `;
                } else {
                    html += `<span class="recap-item">${escapeHtml(check.name)}: <span class="not-found">not found</span></span> `;
                }
            }
            
            html += '</div>';
            return html;
        }
        
        // Scroll to section with highlight
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                section.classList.add('section-highlight');
                setTimeout(() => {
                    section.classList.remove('section-highlight');
                }, 2000);
            }
        }
        
        // Chunks visualization
        function updateChunksVisualization(chunks, file) {
            if (!chunks || chunks.length === 0) return;
            
            // Update inline visualization in metadata tab
            const container = document.getElementById('chunksVisualizationInline');
            let html = '';
            
            // Heatmap
            html += '<div class="heatmap-container">';
            html += '<h3>File Structure Heatmap</h3>';
            html += '<div class="heatmap">';
            
            const colors = {
                'IHDR': '#FF6AC1', 'IDAT': '#6FC3DF', 'IEND': '#3fb950',
                'tEXt': '#7EE787', 'iTXt': '#7EE787', 'zTXt': '#7EE787',
                'gAMA': '#FFA657', 'cHRM': '#FFA657', 'sRGB': '#FFA657',
                'iCCP': '#F778BA', 'pHYs': '#8b949e',
            };
            
            for (const chunk of chunks) {
                const color = colors[chunk.type] || '#30363d';
                const percent = (chunk.length / file.size * 100).toFixed(2);
                html += `<div class="heatmap-segment" style="width: ${percent}%; background: ${color};" title="${chunk.type}: ${chunk.length} bytes"></div>`;
            }
            
            html += '</div>';
            
            // Legend
            html += '<div class="chunk-legend">';
            const usedTypes = [...new Set(chunks.map(c => c.type))];
            for (const type of usedTypes) {
                const color = colors[type] || '#30363d';
                html += `<div class="legend-item"><div class="legend-color" style="background: ${color};"></div>${type}</div>`;
            }
            html += '</div></div>';
            
            // Chunk list (collapsible)
            html += '<div class="chunk-list">';
            html += '<h3 class="expandable" onclick="toggleRow(this)" style="cursor: pointer; display: flex; align-items: center; gap: 10px;">';
            html += '<span class="toggle">+</span> Chunk Details';
            html += '</h3>';
            html += '<div class="nested" style="display: none;">';
            chunks.forEach((chunk, i) => {
                html += `<div class="chunk-item">`;
                html += `<strong>${i + 1}.</strong> `;
                html += `Type: <span class="chunk-type-label">${chunk.type}</span> | `;
                html += `Length: ${chunk.length.toLocaleString()} bytes | `;
                html += `Offset: 0x${chunk.offset.toString(16).toUpperCase()}`;
                html += `</div>`;
            });
            html += '</div></div>';
            
            container.innerHTML = html;
        }
        
        // Export JSON
        function exportJSON() {
            if (!currentMetadata) {
                alert('No metadata to export. Please analyze a file first.');
                return;
            }
            
            const fileName = currentFile.name.replace(/\.[^/.]+$/, "");
            const containerType = currentMetadata.containerType.toLowerCase();
            const exportName = `${fileName}_${containerType}_metadata.json`;
            
            const blob = new Blob([JSON.stringify(currentMetadata, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = exportName;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Copy to clipboard
        function copyToClipboard(text, element) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = element.textContent;
                element.textContent = '[✓]';
                element.classList.add('copied');
                setTimeout(() => {
                    element.textContent = originalText;
                    element.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
            });
        }
        
        // Copy GPS coordinates
        function copyGPSCoords(coords, element) {
            navigator.clipboard.writeText(coords).then(() => {
                const originalText = element.textContent;
                element.textContent = '[ ✓ ]';
                element.style.color = '#3fb950';
                setTimeout(() => {
                    element.textContent = originalText;
                    element.style.color = '#6FC3DF';
                }, 2000);
            }).catch(err => {
                console.error('GPS copy failed:', err);
                alert('Failed to copy coordinates');
            });
        }
        
        // Copy button event delegation
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('copy-text-btn')) {
                const encoded = e.target.getAttribute('data-text-encoded');
                if (encoded) {
                    try {
                        const text = decodeURIComponent(escape(atob(encoded)));
                        copyToClipboard(text, e.target);
                    } catch (err) {
                        console.error('Failed to decode text:', err);
                    }
                }
            }
        });
        
        // Utility functions
        function escapeHtml(text) {
            if (typeof text !== 'string') text = String(text);
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function unescapeUnicode(text) {
            if (typeof text !== 'string') return text;
            // Decode Unicode escape sequences like \u00e8
            return text.replace(/\\u[\dA-F]{4}/gi, match => {
                return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
            });
        }
        
        console.log('$ BareBlocks - Client-side metadata inspector ready');
        console.log('All processing happens in your browser');
        console.log('Files never leave your device');
        
        // ========================================
        // IMAGE MERGER FUNCTIONALITY
        // ========================================
        
        // Global metadata cache for cross-tab integration
        let imageMetadataCache = new Map(); // Maps file.name -> metadata object
        
        let mergeItems = []; // Array of {type: 'image'|'empty', data, text, metadata}
        let mergeDirection = 'grid';
        let imageFit = 'contain';
        let gridColumns = 2;
        let includeEmptyCells = false;
        let emptyCellPattern = 'after'; // 'before' | 'after'
        let emptyCellColor = '#ffffff';
        let selectedCellIndex = 0;
        let isDraggingText = false;
        let dragCellIndex = -1;
        let modalCellIndex = -1;
        let isDraggingModal = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        
        // Generate metadata summary text for empty cells
        function generateMetadataSummary(metadata) {
            if (!metadata) return '';
            
            let summary = [];
            
            // Flatten EXIF data for easier access
            let allExifData = {};
            if (metadata.exif) {
                allExifData = { ...metadata.exif };
                if (metadata.exif.ifd0) Object.assign(allExifData, metadata.exif.ifd0);
                if (metadata.exif.exif) Object.assign(allExifData, metadata.exif.exif);
                if (metadata.exif.gps) Object.assign(allExifData, metadata.exif.gps);
            }
            
            // PRIORITY 1: AI Image with Prompt
            if (metadata.aiMetadata?.hasComfyUI) {
                const ai = metadata.aiMetadata;
                
                // Use resolved prompt if available, otherwise use regular prompt
                let promptText = ai.resolvedPrompt || ai.prompt;
                
                if (promptText) {
                    // Truncate very long prompts (keep first ~300 chars)
                    if (promptText.length > 300) {
                        promptText = promptText.substring(0, 297) + '...';
                    }
                    summary.push(promptText);
                    
                    // Add model info below prompt
                    if (ai.model) {
                        summary.push(`\n📐 ${ai.model}`);
                    }
                    
                    return summary.join('\n');
                }
            }
            
            // PRIORITY 2: Camera/Lens Info
            if (allExifData.Make || allExifData.Model || allExifData.LensModel) {
                if (allExifData.Make || allExifData.Model) {
                    const camera = [allExifData.Make, allExifData.Model].filter(x => x).join(' ').trim();
                    if (camera) summary.push(`📷 ${camera}`);
                }
                if (allExifData.LensModel) {
                    summary.push(`🔍 ${allExifData.LensModel}`);
                }
                
                // Add aperture, shutter, ISO if available
                if (allExifData.FNumber) {
                    summary.push(`f/${allExifData.FNumber}`);
                }
                if (allExifData.ExposureTime) {
                    const shutter = allExifData.ExposureTime < 1 ? 
                        `1/${Math.round(1/allExifData.ExposureTime)}s` : 
                        `${allExifData.ExposureTime}s`;
                    summary.push(shutter);
                }
                if (allExifData.ISO) {
                    summary.push(`ISO ${allExifData.ISO}`);
                }
                
                return summary.join('\n');
            }
            
            // PRIORITY 3: GPS Info
            if (allExifData.GPSLatitude || allExifData.GPSLongitude || allExifData.latitude || allExifData.longitude) {
                summary.push('📍 Location Info:');
                
                const lat = allExifData.latitude || allExifData.GPSLatitude;
                const lon = allExifData.longitude || allExifData.GPSLongitude;
                
                if (lat && lon) {
                    summary.push(`${lat.toFixed(6)}, ${lon.toFixed(6)}`);
                }
                
                if (allExifData.GPSAltitude) {
                    summary.push(`Altitude: ${allExifData.GPSAltitude}m`);
                }
                
                return summary.join('\n');
            }
            
            // FALLBACK: Basic file info
            if (metadata.fileName) {
                summary.push(metadata.fileName);
            }
            
            // Dimensions
            if (metadata.exif?.ImageWidth && metadata.exif?.ImageHeight) {
                summary.push(`${metadata.exif.ImageWidth} × ${metadata.exif.ImageHeight}`);
            }
            
            // Container type and size
            if (metadata.containerType && metadata.fileSize) {
                const sizeMB = (metadata.fileSize / (1024 * 1024)).toFixed(2);
                summary.push(`${metadata.containerType.toUpperCase()} · ${sizeMB} MB`);
            }
            
            return summary.join('\n');
        }
        
        // Initialize default button states
        function initializeMergerDefaults() {
            // Set default active states for buttons
            document.getElementById('merge-grid')?.classList.add('active');
            document.getElementById('fit-contain')?.classList.add('active');
            
            // Set default description
            document.getElementById('fit-description').textContent = 'Scales to fit within cell, maintains aspect ratio';
            
            // Show grid columns by default (since grid is default)
            document.getElementById('grid-columns-container').style.display = 'block';
        }
        
        // Setup merge upload zone (preview container)
        const mergePreviewContainer = document.getElementById('merge-preview-container');
        const mergeFileInput = document.getElementById('mergeFileInput');
        
        if (mergePreviewContainer && mergeFileInput) {
            // Initialize defaults
            initializeMergerDefaults();
            mergePreviewContainer.addEventListener('dblclick', (e) => {
                // Double-click anywhere to add more images
                if (!e.target.classList.contains('draggable-text')) {
                    mergeFileInput.click();
                }
            });
            
            mergePreviewContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                mergePreviewContainer.classList.add('drag-over');
            });
            
            mergePreviewContainer.addEventListener('dragleave', (e) => {
                if (e.target === mergePreviewContainer) {
                    mergePreviewContainer.classList.remove('drag-over');
                }
            });
            
            mergePreviewContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                mergePreviewContainer.classList.remove('drag-over');
                handleMergeFiles(e.dataTransfer.files);
            });
            
            mergeFileInput.addEventListener('change', (e) => {
                handleMergeFiles(e.target.files);
            });
        }
        
        async function handleMergeFiles(files) {
            if (!files || files.length === 0) return;
            
            for (const file of files) {
                if (!file.type.startsWith('image/')) continue;
                
                // Extract metadata for this image
                let metadata = null;
                
                // Check if already in cache
                if (imageMetadataCache.has(file.name)) {
                    console.log(`Using cached metadata for: ${file.name}`);
                    metadata = imageMetadataCache.get(file.name).metadata;
                } else {
                    // Extract fresh metadata
                    try {
                        console.log(`Extracting metadata for: ${file.name}`);
                        metadata = await extractMetadata(file);
                        
                        // Cache it
                        imageMetadataCache.set(file.name, {
                            metadata: metadata,
                            file: file,
                            timestamp: Date.now()
                        });
                    } catch (error) {
                        console.error(`Failed to extract metadata for ${file.name}:`, error);
                    }
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        mergeItems.push({
                            type: 'image',
                            file: file,
                            dataUrl: e.target.result,
                            img: img,
                            width: img.width,
                            height: img.height,
                            metadata: metadata, // Attach metadata
                            text: {
                                content: '',
                                font: 'Arial, sans-serif',
                                size: 48,
                                color: '#ffffff',
                                position: 'center',
                                opacity: 1.0
                            }
                        });
                        updateMergeUI();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        // Empty Cells Functions
        function toggleEmptyCells(enabled) {
            includeEmptyCells = enabled;
            document.getElementById('empty-cells-options').style.display = enabled ? 'block' : 'none';
            rebuildMergeItems();
        }
        
        function setEmptyCellPattern(pattern) {
            emptyCellPattern = pattern;
            document.querySelectorAll('[id^="pattern-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('pattern-' + pattern).classList.add('active');
            rebuildMergeItems();
        }
        
        function setEmptyCellColor(color) {
            emptyCellColor = color;
            document.getElementById('empty-cell-color').value = color;
            document.getElementById('empty-cell-color-text').value = color;
            // Update existing empty cells
            mergeItems.forEach(item => {
                if (item.type === 'empty') {
                    item.color = color;
                }
            });
            updateMergePreview();
        }
        
        function rebuildMergeItems() {
            // Extract only image items
            const images = mergeItems.filter(item => item.type === 'image');
            mergeItems = [];
            
            if (!includeEmptyCells) {
                mergeItems = images;
            } else {
                // Apply pattern
                images.forEach((img, index) => {
                    if (emptyCellPattern === 'before') {
                        // Add empty cell before each image
                        // Use metadata from the image that follows
                        const metadataSummary = img.metadata ? generateMetadataSummary(img.metadata) : 'Text Here';
                        
                        mergeItems.push({
                            type: 'empty',
                            color: emptyCellColor,
                            text: {
                                content: metadataSummary,
                                font: 'Arial, sans-serif',
                                size: 14,
                                color: '#000000',
                                position: 'center',
                                opacity: 1.0
                            }
                        });
                    }
                    mergeItems.push(img);
                    if (emptyCellPattern === 'after') {
                        // Add empty cell after each image
                        // Use metadata from the image that precedes
                        const metadataSummary = img.metadata ? generateMetadataSummary(img.metadata) : 'Text Here';
                        
                        mergeItems.push({
                            type: 'empty',
                            color: emptyCellColor,
                            text: {
                                content: metadataSummary,
                                font: 'Arial, sans-serif',
                                size: 14,
                                color: '#000000',
                                position: 'center',
                                opacity: 1.0
                            }
                        });
                    }
                });
            }
            
            updateMergeUI();
        }
        
        // Text Overlay Functions
        function selectCell(index) {
            selectedCellIndex = parseInt(index);
            if (selectedCellIndex >= 0 && selectedCellIndex < mergeItems.length) {
                const item = mergeItems[selectedCellIndex];
                document.getElementById('cell-text').value = item.text.content || '';
                document.getElementById('text-font').value = item.text.font;
                document.getElementById('text-size').value = item.text.size;
                document.getElementById('text-size-value').textContent = item.text.size;
                document.getElementById('text-color').value = item.text.color;
                document.getElementById('text-color-text').value = item.text.color;
                document.getElementById('text-opacity').value = Math.round(item.text.opacity * 100);
                document.getElementById('text-opacity-value').textContent = Math.round(item.text.opacity * 100);
            }
        }
        
        function updateCellText(text) {
            if (selectedCellIndex >= 0 && selectedCellIndex < mergeItems.length) {
                mergeItems[selectedCellIndex].text.content = text;
                updateMergePreview();
            }
        }
        
        function updateCellTextStyle(property, value) {
            if (selectedCellIndex >= 0 && selectedCellIndex < mergeItems.length) {
                mergeItems[selectedCellIndex].text[property] = value;
                
                // Update active state for position buttons
                if (property === 'position') {
                    const positionContainer = event.target.parentElement;
                    positionContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    event.target.classList.add('active');
                    // Clear custom position when using presets
                    delete mergeItems[selectedCellIndex].text.customX;
                    delete mergeItems[selectedCellIndex].text.customY;
                }
                
                // Sync color text field
                if (property === 'color') {
                    document.getElementById('text-color-text').value = value;
                }
                
                updateMergePreview();
            }
        }
        
        // Text Click/Drag Handler
        let mouseDownTime = 0;
        let mouseDownX = 0;
        let mouseDownY = 0;
        
        function handleTextMouseDown(event, cellIndex) {
            event.stopPropagation();
            mouseDownTime = Date.now();
            mouseDownX = event.clientX;
            mouseDownY = event.clientY;
            dragCellIndex = cellIndex;
            
            // Wait to see if this is a drag or a click
            setTimeout(() => {
                const timeDiff = Date.now() - mouseDownTime;
                const moveDiff = Math.abs(event.clientX - mouseDownX) + Math.abs(event.clientY - mouseDownY);
                
                if (timeDiff < 200 && moveDiff < 5 && !isDraggingText) {
                    // It's a click - open modal
                    openTextModal(cellIndex);
                }
            }, 250);
            
            startDragText(event, cellIndex);
        }
        
        // Text Drag Functions
        function startDragText(event, cellIndex) {
            event.stopPropagation();
            isDraggingText = false; // Start as false, becomes true on movement
            dragCellIndex = cellIndex;
            
            const textElement = event.target;
            const cellElement = textElement.parentElement;
            const cellRect = cellElement.getBoundingClientRect();
            
            function onMouseMove(e) {
                const moveDist = Math.abs(e.clientX - mouseDownX) + Math.abs(e.clientY - mouseDownY);
                
                // Start dragging if moved more than 5px
                if (moveDist > 5) {
                    isDraggingText = true;
                }
                
                if (!isDraggingText) return;
                
                const x = e.clientX - cellRect.left;
                const y = e.clientY - cellRect.top;
                
                // Convert to percentage
                const percentX = Math.max(10, Math.min(90, (x / cellRect.width) * 100));
                const percentY = Math.max(10, Math.min(90, (y / cellRect.height) * 100));
                
                // Update text position
                mergeItems[dragCellIndex].text.customX = percentX;
                mergeItems[dragCellIndex].text.customY = percentY;
                mergeItems[dragCellIndex].text.position = 'custom';
                
                // Update preview
                textElement.style.left = percentX + '%';
                textElement.style.top = percentY + '%';
                textElement.style.transform = 'translate(-50%, -50%)';
            }
            
            function onMouseUp() {
                isDraggingText = false;
                dragCellIndex = -1;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                // Deactivate all position preset buttons
                const positionButtons = document.querySelectorAll('.tab-button');
                positionButtons.forEach(btn => {
                    if (btn.textContent.includes('Top') || btn.textContent.includes('Center') || 
                        btn.textContent.includes('Bottom') || btn.textContent.includes('Left') || 
                        btn.textContent.includes('Right')) {
                        btn.classList.remove('active');
                    }
                });
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }
        
        function updateMergeUI() {
            // Update selected images list
            const listContainer = document.getElementById('selected-images-list');
            const imageCount = mergeItems.filter(item => item.type === 'image').length;
            
            if (mergeItems.length === 0) {
                listContainer.innerHTML = '';
                document.getElementById('merge-download-btn').style.display = 'none';
                document.getElementById('merge-preview').innerHTML = '<p class="info">Add images to see preview</p>';
                document.getElementById('selected-cell').innerHTML = '<option value="0">No items yet</option>';
                return;
            }
            
            let listHtml = '<div class="metadata-section"><div class="section-title">Items (' + mergeItems.length + ')</div>';
            listHtml += '<div style="padding: 10px;">';
            
            mergeItems.forEach((item, index) => {
                listHtml += `<div style="display: flex; align-items: center; gap: 10px; padding: 8px; background: #161b22; margin-bottom: 6px; border-radius: 4px;">`;
                
                if (item.type === 'image') {
                    listHtml += `<img src="${item.dataUrl}" style="width: 40px; height: 40px; object-fit: cover; border-radius: 3px;">`;
                    listHtml += `<div style="flex: 1; font-size: 11px; overflow: hidden;">`;
                    listHtml += `<div style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${item.file.name}</div>`;
                    listHtml += `<div style="color: #8b949e;">${item.width}x${item.height}</div>`;
                    listHtml += `</div>`;
                } else {
                    listHtml += `<div style="width: 40px; height: 40px; background: ${item.color}; border: 1px solid #30363d; border-radius: 3px;"></div>`;
                    listHtml += `<div style="flex: 1; font-size: 11px;">`;
                    listHtml += `<div>Empty Cell</div>`;
                    listHtml += `<div style="color: #8b949e;">${item.color}</div>`;
                    listHtml += `</div>`;
                }
                
                listHtml += `<button onclick="removeMergeItem(${index})" style="background: #21262d; border: 1px solid #30363d; color: #f85149; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">✕</button>`;
                listHtml += `</div>`;
            });
            
            listHtml += '</div></div>';
            listContainer.innerHTML = listHtml;
            
            // Update cell selector dropdown
            const cellSelector = document.getElementById('selected-cell');
            let selectorHtml = '';
            mergeItems.forEach((item, index) => {
                if (item.type === 'image') {
                    selectorHtml += `<option value="${index}">Image ${index + 1} - ${item.file.name.substring(0, 20)}</option>`;
                } else {
                    selectorHtml += `<option value="${index}">Empty Cell ${index + 1}</option>`;
                }
            });
            cellSelector.innerHTML = selectorHtml;
            
            // Select first item by default
            if (selectedCellIndex >= mergeItems.length) {
                selectedCellIndex = 0;
            }
            cellSelector.value = selectedCellIndex;
            selectCell(selectedCellIndex);
            
            // Show download button
            document.getElementById('merge-download-btn').style.display = 'block';
            
            // Update preview
            updateMergePreview();
        }
        
        function removeMergeItem(index) {
            mergeItems.splice(index, 1);
            // If we removed an image, rebuild to maintain empty cell pattern
            if (includeEmptyCells) {
                rebuildMergeItems();
            } else {
                updateMergeUI();
            }
        }
        
        function setMergeDirection(direction) {
            mergeDirection = direction;
            
            // Update button states
            document.querySelectorAll('[id^="merge-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('merge-' + direction).classList.add('active');
            
            // Show/hide grid columns
            document.getElementById('grid-columns-container').style.display = direction === 'grid' ? 'block' : 'none';
            
            updateMergePreview();
        }
        
        function setImageFit(fit) {
            imageFit = fit;
            
            // Update button states
            document.querySelectorAll('[id^="fit-"]').forEach(btn => btn.classList.remove('active'));
            document.getElementById('fit-' + fit).classList.add('active');
            
            // Update description
            const descriptions = {
                'cover': 'Scales to cover entire cell, may crop edges',
                'contain': 'Scales to fit within cell, maintains aspect ratio',
                'fill': 'Stretches to fill entire cell, may distort image',
                'scale': 'Like Contain, but won\'t enlarge small images'
            };
            document.getElementById('fit-description').textContent = descriptions[fit];
            
            updateMergePreview();
        }
        
        function updateGridColumns(value) {
            gridColumns = parseInt(value);
            document.getElementById('grid-columns-value').textContent = gridColumns;
            updateMergePreview();
        }
        
        function calculateMergeDimensions() {
            if (mergeItems.length === 0) return null;
            
            // Find max dimensions for cell sizing (only from images)
            let cellWidth = 0, cellHeight = 0;
            mergeItems.forEach(item => {
                if (item.type === 'image') {
                    cellWidth = Math.max(cellWidth, item.width);
                    cellHeight = Math.max(cellHeight, item.height);
                }
            });
            
            // Default cell size if no images
            if (cellWidth === 0) cellWidth = 800;
            if (cellHeight === 0) cellHeight = 600;
            
            let canvasWidth, canvasHeight;
            
            if (mergeDirection === 'horizontal') {
                canvasWidth = cellWidth * mergeItems.length;
                canvasHeight = cellHeight;
            } else if (mergeDirection === 'vertical') {
                canvasWidth = cellWidth;
                canvasHeight = cellHeight * mergeItems.length;
            } else { // grid
                const rows = Math.ceil(mergeItems.length / gridColumns);
                canvasWidth = cellWidth * gridColumns;
                canvasHeight = cellHeight * rows;
            }
            
            return { width: canvasWidth, height: canvasHeight, cellWidth, cellHeight };
        }
        
        function updateMergePreview() {
            const preview = document.getElementById('merge-preview');
            
            if (mergeItems.length === 0) {
                preview.style.display = 'flex';
                preview.style.alignItems = 'center';
                preview.style.justifyContent = 'center';
                preview.innerHTML = `
                    <div style="text-align: center;">
                        <div class="upload-icon" style="font-size: 48px; margin-bottom: 20px;">[   ]</div>
                        <div style="font-size: 14px; color: #c9d1d9; margin-bottom: 10px;">Click or drag files here to merge</div>
                        <div class="info" style="font-size: 11px;">
                            Supports: JPEG, PNG, TIFF, HEIC<br>
                            All processing happens in your browser
                        </div>
                    </div>
                `;
                document.getElementById('output-dimensions').style.display = 'none';
                return;
            }
            
            // Reset to normal display for preview grid
            preview.style.display = 'block';
            preview.style.alignItems = '';
            preview.style.justifyContent = '';
            
            const dims = calculateMergeDimensions();
            
            // Show final dimensions
            const dimsDisplay = document.getElementById('output-dimensions');
            dimsDisplay.style.display = 'block';
            document.getElementById('dimensions-text').textContent = `${dims.width} × ${dims.height}px`;
            
            // Calculate preview container aspect ratio to match final output
            const aspectRatio = dims.width / dims.height;
            const maxWidth = 900; // max preview width
            const maxHeight = 600; // max preview height
            
            let previewWidth, previewHeight;
            if (aspectRatio > maxWidth / maxHeight) {
                // Width constrained
                previewWidth = maxWidth;
                previewHeight = maxWidth / aspectRatio;
            } else {
                // Height constrained
                previewHeight = maxHeight;
                previewWidth = maxHeight * aspectRatio;
            }
            
            // Build grid style based on merge direction
            let gridStyle = `display: grid; gap: 2px; width: ${previewWidth}px; height: ${previewHeight}px; margin: 0 auto;`;
            
            if (mergeDirection === 'horizontal') {
                gridStyle += ` grid-template-columns: repeat(${mergeItems.length}, 1fr);`;
            } else if (mergeDirection === 'vertical') {
                gridStyle += ` grid-template-rows: repeat(${mergeItems.length}, 1fr);`;
            } else { // grid (default)
                const rows = Math.ceil(mergeItems.length / gridColumns);
                gridStyle += ` grid-template-columns: repeat(${gridColumns}, 1fr); grid-template-rows: repeat(${rows}, 1fr);`;
            }
            
            let html = `<div style="${gridStyle}">`;
            
            mergeItems.forEach((item, index) => {
                html += `<div style="border: 1px solid #30363d; overflow: hidden; background: ${item.type === 'empty' ? item.color : '#000'}; position: relative; display: flex; align-items: center; justify-content: center;">`;
                
                if (item.type === 'image') {
                    const fitStyle = imageFit === 'cover' ? 'cover' : imageFit === 'contain' ? 'contain' : imageFit === 'fill' ? 'fill' : 'scale-down';
                    html += `<img src="${item.dataUrl}" style="width: 100%; height: 100%; object-fit: ${fitStyle}; position: absolute; top: 0; left: 0;">`;
                }
                
                // Render text overlay if present
                if (item.text && item.text.content) {
                    const textStyle = `
                        position: absolute;
                        color: ${item.text.color};
                        font-family: ${item.text.font};
                        font-size: ${Math.max(12, item.text.size * (previewWidth / dims.width))}px;
                        opacity: ${item.text.opacity};
                        white-space: pre-wrap;
                        text-align: center;
                        padding: 10px;
                        max-width: 90%;
                        word-wrap: break-word;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                        cursor: move;
                        user-select: none;
                        pointer-events: auto;
                    `;
                    
                    let positionStyle = '';
                    
                    // Check if custom position exists
                    if (item.text.customX !== undefined && item.text.customY !== undefined) {
                        positionStyle = `left: ${item.text.customX}%; top: ${item.text.customY}%; transform: translate(-50%, -50%);`;
                    } else {
                        // Use preset positions
                        switch(item.text.position) {
                            case 'top':
                                positionStyle = 'top: 10px; left: 50%; transform: translateX(-50%);';
                                break;
                            case 'bottom':
                                positionStyle = 'bottom: 10px; left: 50%; transform: translateX(-50%);';
                                break;
                            case 'left':
                                positionStyle = 'left: 10px; top: 50%; transform: translateY(-50%); text-align: left;';
                                break;
                            case 'right':
                                positionStyle = 'right: 10px; top: 50%; transform: translateY(-50%); text-align: right;';
                                break;
                            default: // center
                                positionStyle = 'top: 50%; left: 50%; transform: translate(-50%, -50%);';
                        }
                    }
                    
                    html += `<div class="draggable-text" data-cell-index="${index}" onmousedown="handleTextMouseDown(event, ${index})" style="${textStyle} ${positionStyle}">${escapeHtml(item.text.content)}</div>`;
                }
                
                html += `</div>`;
            });
            
            html += '</div>';
            preview.innerHTML = html;
        }
        
        // Text Edit Modal Functions
        function openTextModal(cellIndex) {
            if (isDraggingText) return; // Don't open if we're dragging
            
            modalCellIndex = cellIndex;
            const modal = document.getElementById('text-edit-modal');
            
            // Load current text and settings
            if (cellIndex >= 0 && cellIndex < mergeItems.length) {
                const textConfig = mergeItems[cellIndex].text;
                document.getElementById('modal-text-input').value = textConfig.content || '';
                document.getElementById('modal-text-font').value = textConfig.font;
                document.getElementById('modal-text-size').value = textConfig.size;
                document.getElementById('modal-text-size-value').textContent = textConfig.size;
                document.getElementById('modal-text-color').value = textConfig.color;
                document.getElementById('modal-text-color-text').value = textConfig.color;
                document.getElementById('modal-text-opacity').value = Math.round(textConfig.opacity * 100);
                document.getElementById('modal-text-opacity-value').textContent = Math.round(textConfig.opacity * 100);
            }
            
            // Show modal
            modal.style.display = 'flex';
            document.getElementById('modal-text-input').focus();
            document.getElementById('modal-text-input').select();
            
            // Setup modal dragging
            const modalContent = document.getElementById('modal-content');
            const modalHeader = document.getElementById('modal-header');
            
            modalHeader.onmousedown = function(e) {
                isDraggingModal = true;
                const rect = modalContent.getBoundingClientRect();
                modalOffsetX = e.clientX - rect.left;
                modalOffsetY = e.clientY - rect.top;
            };
            
            // Setup live updates
            document.getElementById('modal-text-size').oninput = function(e) {
                document.getElementById('modal-text-size-value').textContent = e.target.value;
            };
            
            document.getElementById('modal-text-opacity').oninput = function(e) {
                document.getElementById('modal-text-opacity-value').textContent = e.target.value;
            };
            
            document.getElementById('modal-text-color').onchange = function(e) {
                document.getElementById('modal-text-color-text').value = e.target.value;
            };
            
            document.getElementById('modal-text-color-text').onchange = function(e) {
                document.getElementById('modal-text-color').value = e.target.value;
            };
            
            // Handle Escape key
            document.getElementById('modal-text-input').onkeydown = function(e) {
                if (e.key === 'Escape') {
                    closeTextModal(false);
                }
            };
        }
        
        function closeTextModal(save) {
            const modal = document.getElementById('text-edit-modal');
            
            if (save && modalCellIndex >= 0 && modalCellIndex < mergeItems.length) {
                // Save all settings
                mergeItems[modalCellIndex].text.content = document.getElementById('modal-text-input').value;
                mergeItems[modalCellIndex].text.font = document.getElementById('modal-text-font').value;
                mergeItems[modalCellIndex].text.size = parseInt(document.getElementById('modal-text-size').value);
                mergeItems[modalCellIndex].text.color = document.getElementById('modal-text-color').value;
                mergeItems[modalCellIndex].text.opacity = parseInt(document.getElementById('modal-text-opacity').value) / 100;
                
                updateMergePreview();
            }
            
            modal.style.display = 'none';
            modalCellIndex = -1;
            
            // Clean up
            const modalContent = document.getElementById('modal-content');
            modalContent.style.left = '';
            modalContent.style.top = '';
            modalContent.style.transform = '';
        }
        
        // Setup modal dragging globally
        document.addEventListener('mousemove', function(e) {
            if (isDraggingModal) {
                const modalContent = document.getElementById('modal-content');
                modalContent.style.position = 'fixed';
                modalContent.style.left = (e.clientX - modalOffsetX) + 'px';
                modalContent.style.top = (e.clientY - modalOffsetY) + 'px';
                modalContent.style.transform = 'none';
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isDraggingModal) {
                isDraggingModal = false;
            }
        });
        
        // Close modal when clicking outside
        document.getElementById('text-edit-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTextModal(false);
            }
        });
        
        async function downloadMergedImage() {
            if (mergeItems.length === 0) return;
            
            // Calculate canvas dimensions using shared function
            const dims = calculateMergeDimensions();
            const canvasWidth = dims.width;
            const canvasHeight = dims.height;
            const cellWidth = dims.cellWidth;
            const cellHeight = dims.cellHeight;
            
            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');
            
            // Fill background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Draw items (images and empty cells)
            mergeItems.forEach((item, index) => {
                let x, y;
                
                if (mergeDirection === 'horizontal') {
                    x = index * cellWidth;
                    y = 0;
                } else if (mergeDirection === 'vertical') {
                    x = 0;
                    y = index * cellHeight;
                } else { // grid
                    const row = Math.floor(index / gridColumns);
                    const col = index % gridColumns;
                    x = col * cellWidth;
                    y = row * cellHeight;
                }
                
                if (item.type === 'image') {
                    // Draw image
                    if (imageFit === 'cover' || imageFit === 'contain') {
                        const scale = imageFit === 'cover' 
                            ? Math.max(cellWidth / item.width, cellHeight / item.height)
                            : Math.min(cellWidth / item.width, cellHeight / item.height);
                        
                        const scaledWidth = item.width * scale;
                        const scaledHeight = item.height * scale;
                        const offsetX = (cellWidth - scaledWidth) / 2;
                        const offsetY = (cellHeight - scaledHeight) / 2;
                        
                        ctx.drawImage(item.img, x + offsetX, y + offsetY, scaledWidth, scaledHeight);
                    } else { // fill or scale-down
                        ctx.drawImage(item.img, x, y, cellWidth, cellHeight);
                    }
                } else {
                    // Draw empty cell
                    ctx.fillStyle = item.color;
                    ctx.fillRect(x, y, cellWidth, cellHeight);
                }
                
                // Draw text overlay if present
                if (item.text && item.text.content) {
                    ctx.save();
                    ctx.font = `${item.text.size}px ${item.text.font}`;
                    ctx.fillStyle = item.text.color;
                    ctx.globalAlpha = item.text.opacity;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Add text shadow for better visibility
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    
                    // Calculate text position
                    let textX, textY;
                    const padding = 20;
                    
                    // Check for custom position first
                    if (item.text.customX !== undefined && item.text.customY !== undefined) {
                        textX = x + (cellWidth * item.text.customX / 100);
                        textY = y + (cellHeight * item.text.customY / 100);
                    } else {
                        // Use preset positions
                        switch(item.text.position) {
                            case 'top':
                                textX = x + cellWidth / 2;
                                textY = y + item.text.size + padding;
                                break;
                            case 'bottom':
                                textX = x + cellWidth / 2;
                                textY = y + cellHeight - padding;
                                break;
                            case 'left':
                                textX = x + padding;
                                textY = y + cellHeight / 2;
                                ctx.textAlign = 'left';
                                break;
                            case 'right':
                                textX = x + cellWidth - padding;
                                textY = y + cellHeight / 2;
                                ctx.textAlign = 'right';
                                break;
                            default: // center
                                textX = x + cellWidth / 2;
                                textY = y + cellHeight / 2;
                        }
                    }
                    
                    // Wrap text if too long
                    const maxWidth = cellWidth - (padding * 2);
                    const words = item.text.content.split(' ');
                    let lines = [];
                    let currentLine = words[0];
                    
                    for (let i = 1; i < words.length; i++) {
                        const testLine = currentLine + ' ' + words[i];
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth) {
                            lines.push(currentLine);
                            currentLine = words[i];
                        } else {
                            currentLine = testLine;
                        }
                    }
                    lines.push(currentLine);
                    
                    // Draw each line
                    const lineHeight = item.text.size * 1.2;
                    const totalHeight = lines.length * lineHeight;
                    let startY = textY - (totalHeight / 2) + (lineHeight / 2);
                    
                    if (item.text.position === 'top') {
                        startY = textY;
                    } else if (item.text.position === 'bottom') {
                        startY = textY - totalHeight + lineHeight;
                    }
                    
                    lines.forEach((line, i) => {
                        ctx.fillText(line, textX, startY + (i * lineHeight));
                    });
                    
                    ctx.restore();
                }
            });
            
            // Download
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `merged_${mergeDirection}_${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png');
        }
    </script>
</body>
</html>
